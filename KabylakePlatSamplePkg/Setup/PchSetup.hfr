/** @file

 @copyright
  INTEL CONFIDENTIAL
  Copyright 2014 - 2019 Intel Corporation.

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.

  This file contains a 'Sample Driver' and is licensed as such under the terms
  of your license agreement with Intel or your vendor. This file may be modified
  by the user, subject to the additional terms of the license agreement.

@par Specification
**/

// AMI_OVERRIDE_START
#ifdef CHIPSET_FORM_SET

#ifdef FORM_SET_GOTO
  // Define goto commands for the forms defined in this file
  goto SB_FORM_ID, 
    prompt  = STRING_TOKEN (STR_SB_FORM),
    help    = STRING_TOKEN (STR_SB_FORM_HELP);
#endif // End of FORM_SET_GOTO
    
#ifdef FORM_SET_FORM
// AMI_OVERRIDE_END
    // Define forms
    form formid = AUTO_ID(SB_FORM_ID),
    title       = STRING_TOKEN(STR_SB_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_SB_FORM_SUBTITLE))
    SEPARATOR

    goto PCIE_DEVICE_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_PCIE_OPTIONS_FORM),
         help = STRING_TOKEN(STR_PCIE_OPTIONS_FORM_HELP);

    goto SATA_DEVICE_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM),
         help = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_HELP);

    goto USB_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_USB_OPTIONS_FORM),
         help = STRING_TOKEN(STR_USB_OPTIONS_FORM_HELP);

    goto SECURITY_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_SECURITY_OPTIONS_FORM),
         help = STRING_TOKEN(STR_SECURITY_OPTIONS_FORM_HELP);

    suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
        goto PCH_HDAUDIO_OPTIONS_FORM_ID,
             prompt = STRING_TOKEN(STR_HDAUDIO_OPTIONS_FORM_TITLE),
             help = STRING_TOKEN(STR_HDAUDIO_OPTIONS_FORM_HELP);
    endif;

    goto STR_122_FORM_ID, // AMI_OVERRIDE //SerialIo
         prompt = STRING_TOKEN(STR_SERIAL_IO_OPTIONS_FORM),
         help = STRING_TOKEN(STR_SERIAL_IO_OPTIONS_FORM_HELP);

    suppressif NOT ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3
                                                             BoardIdSkylakeA0Rvp3Ppv
                                                             BoardIdSkylakeULpddr3Rvp5
                                                             BoardIdSkylakeULpddr3Rvp5Ppv
                                                             BoardIdSkylakeLpdimmDoe
                                                             BoardIdSkylakeURvp7
                                                             BoardIdKabylakeRDdr4
                                                             BoardIdKabylakeRLpddr3
                                                             BoardIdKabylakeKcDdr3
                                                             BoardIdSkylakeURvp7Ppv
                                                             BoardIdSkylakeYRvp13
                                                             BoardIdAmberLakeLpddr3Rvp13
                                                             BoardIdSkylakeURvp15
                                                             BoardIdSkylakePantherMtn
                                                             BoardIdSkylakeSds;
    goto SKYCAM_CIO2_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_SKYCAM_CIO2_OPTIONS_FORM_TITLE),
         help = STRING_TOKEN(STR_SKYCAM_CIO2_OPTIONS_FORM_TITLE);
    endif;

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx;
    goto SCS_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_SCS_OPTIONS_FORM_TITLE),
         help = STRING_TOKEN(STR_SCS_OPTIONS_FORM_HELP);
    endif;

    suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
	goto ISH_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_ISH_OPTIONS_FORM_TITLE),
         help = STRING_TOKEN(STR_ISH_OPTIONS_FORM_HELP);
    endif;

    goto PCH_TRACE_HUB_OPTIONS_FORM_ID,
         prompt = STRING_TOKEN(STR_TRACE_HUB_CONFIG_TITLE),
         help = STRING_TOKEN(STR_TRACE_HUB_FORM_HELP);

    goto PCH_THERMAL_THROTTLING_OPTIONS_FORM_ID,
        prompt   = STRING_TOKEN(STR_PCH_THERMAL_THROTTLING),
        help     = STRING_TOKEN(STR_PCH_THERMAL_THROTTLING),
        flags   = 0,
        key     = 0;

// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      goto SB_PORTING_FORM_ID, 
        prompt = STRING_TOKEN(STR_SB_PORTING_FORM_FORM_TITLE),
        help = STRING_TOKEN(STR_SB_PORTING_CONFIGURATION_HELP);
#endif	
// AMI_OVERRIDE_END <<<  

    SEPARATOR

	oneof varid = PCH_SETUP.PchDciEn,
      prompt   = STRING_TOKEN(STR_PCH_DCI_HDCIEN),
      help     = STRING_TOKEN(STR_PCH_DCI_HDCIEN_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeULpddr3Rvp5 AND
               NOT ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeULpddr3Rvp5Ppv;
    oneof varid     = SETUP_DATA.DebugUsbUart,
        prompt      = STRING_TOKEN(STR_DEBUG_USB_UART),
        help        = STRING_TOKEN(STR_DEBUG_USB_UART_HELP),
        option text = STRING_TOKEN(STR_DEBUG_USB_UART_UART), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DEBUG_USB_UART_USB), value = 1, flags = RESET_REQUIRED;
    endoneof;
    endif;

    oneof varid     = PCH_SETUP.OsDebugPort,
        prompt      = STRING_TOKEN(STR_DEBUG_PORT),
        help        = STRING_TOKEN(STR_DEBUG_PORT_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_DEBUG_PORT_LEGACY_UART), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                         ? 0x0:0x3), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_DEBUG_PORT_LEGACY_UART), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART2] == 1 OR
                   ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C4] == 1 OR
                   ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C5] == 1;
        option text = STRING_TOKEN(STR_DEBUG_PORT_SERIALIO_UART2), value = 3, flags = RESET_REQUIRED;
        endif
    endoneof;

    oneof varid  = SETUP_DATA.GnssConnection,
      prompt   = STRING_TOKEN(STR_PCH_GNSS_CONNECTION),
      help     = STRING_TOKEN(STR_PCH_GNSS_CONNECTION_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART1] == 0;
        option text = STRING_TOKEN(STR_CONNECTED_TO_SERIALIO), value = 1, flags = RESET_REQUIRED;
      endif
      suppressif ideqval PCH_SETUP.PchIshEnable == 0;
        option text = STRING_TOKEN(STR_CONNECTED_TO_ISH), value = 2, flags = RESET_REQUIRED;
      endif
    endoneof;

    suppressif ideqval SETUP_DATA.GnssConnection == 0;
      oneof varid  = SETUP_DATA.GnssModel,
        prompt   = STRING_TOKEN(STR_PCH_GNSS_MODEL),
        help     = STRING_TOKEN(STR_PCH_GNSS_MODEL),
        option text = STRING_TOKEN(STR_PCH_GNSS_CG2000), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    //
    // GbE Region present
    //
    suppressif ideqval SETUP_VOLATILE_DATA.GbeAvailable == 0;
    oneof varid = PCH_SETUP.PchLan,
      prompt   = STRING_TOKEN(STR_PCH_LAN_CONTROLLER_PROMPT),
      help     = STRING_TOKEN(STR_PCH_LAN_CONTROLLER_HELP),
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;
    endif;

    //
    // GbE Region not available
    //
    suppressif ideqval SETUP_VOLATILE_DATA.GbeAvailable == 1;
      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_PCH_LAN_CONTROLLER),
        text   = STRING_TOKEN(STR_PCH_LAN_NOT_PRESENT),
        flags  = 0,
        key    = 0;
    endif;

     suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorMobile AND
                NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorEmbedded;
      oneof varid = SETUP_DATA.SensorHubType,
       prompt   = STRING_TOKEN(STR_SENSOR_HUB_TYPE),
       help     = STRING_TOKEN(STR_SENSOR_HUB_TYPE_HELP),
       option text = STRING_TOKEN(STR_NONE_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_I2C_SENSOR_HUB_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_USB_SENSOR_HUB_STRING), value = 2, flags = RESET_REQUIRED;
      endoneof;
      endif;

    suppressif ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
      oneof varid = PCH_SETUP.DeepSxMode,
        prompt   = STRING_TOKEN(STR_DEEP_SX_POWER_POLICIES_PROMPT),
        help     = STRING_TOKEN(STR_DEEP_SX_POWER_POLICIES_HELP),
        option text = STRING_TOKEN(STR_DISABLED),                    value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorDesktop OR
                   ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer OR
                   ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorWorkstation;
          option text = STRING_TOKEN(STR_DEEPSX_S4_S5_BATT_STRING),    value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DEEPSX_S3_S4_S5_BATT_STRING), value = 5, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DEEPSX_S3_S4_S5_STRING),      value = 6, flags = RESET_REQUIRED;
        endif
        option text = STRING_TOKEN(STR_DEEPSX_S4_S5_STRING),         value = 4, flags = RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid = PCH_SETUP.LanWakeFromDeepSx,
      prompt   = STRING_TOKEN(STR_PCH_LAN_WAKE_WFDSX_PROMPT),
      help     = STRING_TOKEN(STR_PCH_LAN_WAKE_WFDSX_HELP),
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;


    suppressif ideqval PCH_SETUP.PchLan == 0;
      oneof varid = PCH_SETUP.PchWakeOnLan,
        prompt   = STRING_TOKEN(STR_PCH_LAN_WOL_PROMPT),
        help     = STRING_TOKEN(STR_PCH_LAN_WOL_HELP),
        //
        // The default setup option has been changed from Disabled to Enabled to sync with Greens Glacier and to fix the
        // SelfTest error LPC Controller (Bus 0 Dev 31 Fun 0) 0A4[8]
        //
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = PCH_SETUP.SlpLanLowDc,
        prompt   = STRING_TOKEN(STR_PCH_SLP_LAN_LOW_DC_PROMPT),
        help     = STRING_TOKEN(STR_PCH_SLP_LAN_LOW_DC_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = PCH_SETUP.PchLanK1Off,
        prompt   = STRING_TOKEN(STR_PCH_LAN_K1_OFF_PROMPT),
        help     = STRING_TOKEN(STR_PCH_LAN_K1_OFF_HELP),
// AMI_OVERRIDE_START
//        default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb ? 0x1:0x0), defaultstore = MyStandardDefault,  // AdvancedFeaturesContent
// AMI_OVERRIDE_END  
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;

#if 0  // AMI_OVERRIDE_START
      oneof varid = SETUP_DATA.EfiNetworkSupport,
        prompt   = STRING_TOKEN(STR_EFI_NETWORK_CONTROL),
        help     = STRING_TOKEN(STR_EFI_NETWORK_CONTROL_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
      endoneof;
#endif  // AMI_OVERRIDE_END      
    endif;

    oneof varid = PCH_SETUP.PchWakeOnWlan,
        prompt   = STRING_TOKEN(STR_PCH_WOWLAN_PROMPT),
        help     = STRING_TOKEN(STR_PCH_WOWLAN_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PchWakeOnWlan == 0;
      oneof varid = PCH_SETUP.PchWakeOnWlanDeepSx,
          prompt   = STRING_TOKEN(STR_PCH_WOWLANDEEPSX_PROMPT),
          help     = STRING_TOKEN(STR_PCH_WOWLANDEEPSX_HELP),
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid = PCH_SETUP.DisableDsxAcPresentPulldown,
        prompt   = STRING_TOKEN(STR_DISABLE_DSX_ACPRESENT_PD_PROMPT),
        help     = STRING_TOKEN(STR_DISABLE_DSX_ACPRESENT_PD_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloDdr4Rvp11
//                                                                       BoardIdKabylakeDdr4Rvp17 // KblGContent
//                                                                       BoardIdSkylakeHaloLpddr3Rvp16
//								       ? 0x0:0x1), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
    endoneof;


#if 0  // AMI_OVERRIDE_START
    oneof varid = SETUP_DATA.PxeRom,
      prompt   = STRING_TOKEN(STR_PCH_PXEROM_CONTROL),
      help     = STRING_TOKEN(STR_PCH_PXEROM_CONTROL_HELP),
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
    endoneof;
#endif  // AMI_OVERRIDE_END

    oneof varid  = PCH_SETUP.PchLpcClockRun,
      prompt   = STRING_TOKEN(STR_PCH_LPCCLOCKRUN_PROMPT),
      help     = STRING_TOKEN(STR_PCH_LPCCLOCKRUN_HELP),
// AMI_OVERRIDE_START       
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END       
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    
    endoneof;

    oneof varid  = PCH_SETUP.PchSirqMode,
      prompt   = STRING_TOKEN(STR_PCH_SIRQ_MODE),
      help     = STRING_TOKEN(STR_PCH_SIRQ_MODE_HELP),
// AMI_OVERRIDE_START
      default      = SIRQ_DEFAULT_MODE,
      option text = STRING_TOKEN(STR_SIRQ_MODE_QUIET), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeSdlBrk BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
//                                                                   ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_SIRQ_MODE_QUIET), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_SIRQ_MODE_CONTINUOUS), value = 1, flags = RESET_REQUIRED;
    endoneof;

  oneof varid  = PCH_SETUP.PchPort61hSmm,
    prompt   = STRING_TOKEN(STR_PORT61H_SMM),
    help     = STRING_TOKEN(STR_PORT61H_SMM_HELP),
    //
    // Set Port61 simulation default to TRUE for the CSM enable case for CRB bios
    // due to system loops while launching AHCIROM.
    //
    option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

#if HPET_SUPPORT
    //
    // This is used to configure the HPET default setting.
    // It's not showed in setup menu since the HPET should be always enabled in INTEL platform.
    //
    suppressif TRUE;
    oneof varid = PCH_SETUP.Hpet,
      prompt   = STRING_TOKEN(STR_HPET_PROMPT),
      help     = STRING_TOKEN(STR_HPET_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    endif;
#endif

    oneof varid  = PCH_SETUP.StateAfterG3,
      prompt   = STRING_TOKEN(STR_STATE_AFTER_G3),
      help     = STRING_TOKEN(STR_STATE_AFTER_G3_HELP),
      option text = STRING_TOKEN(STR_S0_AFTER_G3_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_S5_AFTER_G3_STRING), value = 1, flags = RESET_REQUIRED;
//ray_override / [XI-BringUp] Bring Up Porting / AC Power Loss from PCH : Always ON / Added >>
      option text = STRING_TOKEN(STR_LAST_AFTER_G3_STRING), value = 2, flags = RESET_REQUIRED;
//ray_override / [XI-BringUp] Bring Up Porting / AC Power Loss from PCH : Always ON / Added <<
    endoneof;

    oneof varid = PCH_SETUP.IchPort80Route,
      prompt   = STRING_TOKEN(PORT_80_REDIRECT),
      help     = STRING_TOKEN(PORT_80_REDIRECT_HELP),
      option text = STRING_TOKEN(STR_LPC_BUS), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_BUS), value = 1, flags = RESET_REQUIRED;
    endoneof;

    grayoutif NOT ideqval PCH_SETUP.IchPort80Route == 0;
      oneof varid = PCH_SETUP.EnhancePort8xhDecoding,
        prompt   = STRING_TOKEN(ENHANCE_PORT_80_DECODING),
        help     = STRING_TOKEN(ENHANCE_PORT_80_DECODING_HELP),
// AMI_OVERRIDE_START	
//	default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb ? 0x1:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END	
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
    oneof varid    = PCH_SETUP.PchCrid,
        questionid   = AUTO_ID(SB_CRID_KEY),
        prompt       = STRING_TOKEN (STR_PCH_CRID_PROMPT),
        help         = STRING_TOKEN (STR_PCH_CRID_HELP),
        default      = DEFAULT_CRID_ENABLE,
        option text  = STRING_TOKEN (STR_COMMON_DISABLED), value = 0, flags = RESET_REQUIRED | INTERACTIVE;
        option text  = STRING_TOKEN (STR_COMMON_ENABLED), value = 1, flags = MANUFACTURING | RESET_REQUIRED | INTERACTIVE;
    endoneof;
#else    
    oneof varid  = PCH_SETUP.PchCrid,
      prompt   = STRING_TOKEN(STR_PCH_CRID_PROMPT),
      help     = STRING_TOKEN(STR_PCH_CRID_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
#endif    
// AMI_OVERRIDE_END <<<        

    oneof varid  = PCH_SETUP.PchCrossThrottling,
      prompt   = STRING_TOKEN(STR_PCH_CROSS_THROTTLING_PROMPT),
      help     = STRING_TOKEN(STR_PCH_CROSS_THROTTLING_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid  = PCH_SETUP.PchDisableEnergyReport,
      prompt   = STRING_TOKEN(STR_PCH_DISABLE_ENERGY_REPORTING_PROMPT),
      help     = STRING_TOKEN(STR_PCH_DISABLE_ENERGY_REPORTING_HELP),
      option text = STRING_TOKEN(STR_FALSE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRUE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.EnableTcoTimer,
      prompt      = STRING_TOKEN(STR_ENABLE_TCO_TIMER),
      help        = STRING_TOKEN(STR_ENABLE_TCO_TIMER_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
    oneof varid = PCH_SETUP.PciePllSsc,
      prompt   = STRING_TOKEN(STR_PCIE_PLL_SSC_PROMPT),
      help     = STRING_TOKEN(STR_PCIE_PLL_SSC_HELP),
      option text = STRING_TOKEN(STR_AUTO_STRING), value = 0xFF, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PERCENT), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_1_PERCENT), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_2_PERCENT), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_3_PERCENT), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_4_PERCENT), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_5_PERCENT), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_6_PERCENT), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_7_PERCENT), value = 7, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_8_PERCENT), value = 8, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ZERO_PT_9_PERCENT), value = 9, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_0_PERCENT), value = 10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_1_PERCENT), value = 11, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_2_PERCENT), value = 12, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_3_PERCENT), value = 13, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_4_PERCENT), value = 14, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_5_PERCENT), value = 15, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_6_PERCENT), value = 16, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_7_PERCENT), value = 17, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_8_PERCENT), value = 18, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ONE_PT_9_PERCENT), value = 19, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TWO_PT_0_PERCENT), value = 20, flags = RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx AND
               NOT ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeDtRvp8Crb AND  // AdvancedFeaturesContent
               NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
      oneof varid   = PCH_SETUP.PchIoApic24119Entries,
        prompt      = STRING_TOKEN(STR_IOAPIC_24_119_ENTRIES),
        help        = STRING_TOKEN(STR_IOAPIC_24_119_ENTRIES_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid  = PCH_SETUP.PchP2sbUnlock,
      prompt      = STRING_TOKEN(STR_PCH_P2SB_UNLOCK),
      help        = STRING_TOKEN(STR_PCH_P2SB_UNLOCK_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.FprrEnable,
      prompt      = STRING_TOKEN(STR_FPRR_ENABLE),
      help        = STRING_TOKEN(STR_FPRR_ENABLE_HELP),
// AMI_OVERRIDE_START                                                    
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END      
    endoneof;

    oneof varid   = PCH_SETUP.SmbusSpdWriteDisable,
      prompt      = STRING_TOKEN(STR_SMBUS_SPDWDIS),
      help        = STRING_TOKEN(STR_SMBUS_SPDWDIS_HELP),
// AMI_OVERRIDE_START
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                  ? 0x1:0x0), defaultstore = MyStandardDefault,
      option text = STRING_TOKEN(STR_FALSE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRUE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      option text = STRING_TOKEN(STR_TRUE), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
    endoneof;

    oneof varid   = PCH_SETUP.HybridStorageMode,
      prompt      = STRING_TOKEN(STR_HYBDRID_STORAGE_MODE_PROMPT),
      help        = STRING_TOKEN(STR_HYBRID_STORAGE_MODE_HELP),
      option text = STRING_TOKEN(STR_DYNAMIC_ENABLED), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    checkbox varid    = PCH_SETUP.ChipsetInitMessage,
      prompt   = STRING_TOKEN(STR_CHIPSETINIT_MESSAGE_PROMPT),
      help     = STRING_TOKEN(STR_CHIPSETINIT_MESSAGE_HELP),
      // Flags behavior for checkbox is overloaded so that it equals
      // a DEFAULT value.  CHECKBOX_DEFAULT = ON, 0 = off
      flags    = CHECKBOX_DEFAULT | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    oneof varid    = PCH_SETUP.BypassPhySyncReset,
      prompt   = STRING_TOKEN(STR_BYPASS_SYNC_RESET_PROMPT),
      help     = STRING_TOKEN(STR_BYPASS_SYNC_RESET_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                   ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    endform;





  form formid   = AUTO_ID(PCIE_DEVICE_OPTIONS_FORM_ID),
    title         = STRING_TOKEN(STR_PCIE_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_PCIE_OPTIONS_FORM_SUBTITLE))
    SEPARATOR

    oneof varid     = PCH_SETUP.PcieClockGatingDisabled,
        prompt      = STRING_TOKEN(STR_PCIE_CKG_PROMPT),
        help        = STRING_TOKEN(STR_PCIE_CKG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid  = PCH_SETUP.PchLegacyIoLowLatency,
      prompt      = STRING_TOKEN(STR_PCH_LEGACY_IO_LOW_LATENCY),
      help        = STRING_TOKEN(STR_PCH_LEGACY_IO_LOW_LATENCY_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    grayoutif ideqval PCH_SETUP.PchLegacyIoLowLatency == 1;
    oneof varid     = PCH_SETUP.PchDmiAspm,
        prompt      = STRING_TOKEN(STR_PCH_DMI_ASPM_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DMI_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    endif;

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_PCIE_LAN_PROMPT),
      text   = STRING_TOKEN(STR_PCIE_LAN_VALUE),
      flags = 0, key = 0;

    oneof varid   = PCH_SETUP.PcieRootPort8xhDecode,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_PORT8XH_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_PORT8XH_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPort8xhDecode == 0;
      numeric varid = PCH_SETUP.Pcie8xhDecodePortIndex,
        prompt      = STRING_TOKEN (STR_PCH_PCIE_PORT8XH_PORT_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_PORT8XH_PORT_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 20,
        step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default     = 0,    // PCIe Port0 as default
      endnumeric;
    endif;

    oneof varid   = PCH_SETUP.PcieRootPortPeerMemoryWriteEnable,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_PEERMEMORYWRITE_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_PEERMEMORYWRITE_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.PcieComplianceTestMode,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_COMPLIANCETEST_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_COMPLIANCETEST_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.PcieUsbGlitchWa,
      prompt      = STRING_TOKEN(STR_PCIE_USB_WA),
      help        = STRING_TOKEN(STR_PCIE_USB_WA_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.RpFunctionSwap,
      prompt      = STRING_TOKEN(STR_PCIE_RP_SWAP),
      help        = STRING_TOKEN(STR_PCIE_RP_SWAP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    goto PCH_PCIE_LANE_EQ_FORM_ID,
      prompt = STRING_TOKEN(STR_PCIE_LANE_EQ_FORM_TITLE),
      help   = STRING_TOKEN(STR_PCIE_LANE_EQ_FORM_HELP);

    SEPARATOR

    //
    // Controller 1: Port 1 - 4
    //
    goto PCH_PCIERP1_OPTIONS_FORM_ID,
      prompt = STRING_TOKEN(STR_PCIERP1_OPTIONS_FORM_TITLE),
      help = STRING_TOKEN(STR_PCIERP1_OPTIONS_FORM_HELP);

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieControllerCfg1 == 0;
      goto PCH_PCIERP2_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_PCIERP2_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_PCIERP2_OPTIONS_FORM_HELP);
    endif;

    suppressif (ideqval SETUP_VOLATILE_DATA.PcieControllerCfg1 == 3) OR
               (ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 3);
      goto PCH_PCIERP3_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_PCIERP3_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_PCIERP3_OPTIONS_FORM_HELP);
    endif;

    suppressif (ideqvallist SETUP_VOLATILE_DATA.PcieControllerCfg1 == 2 3) OR
               (ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 4);
      goto PCH_PCIERP4_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_PCIERP4_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_PCIERP4_OPTIONS_FORM_HELP);
    endif;

    //
    // Controller 2: Port 5 - 8
    //
    suppressif ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 5;
      goto PCH_PCIERP5_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_PCIERP5_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_PCIERP5_OPTIONS_FORM_HELP);
    endif;

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieControllerCfg2 == 0;
      goto PCH_PCIERP6_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_PCIERP6_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_PCIERP6_OPTIONS_FORM_HELP);
    endif;

    suppressif ideqval SETUP_VOLATILE_DATA.PcieControllerCfg2 == 3;
      goto PCH_PCIERP7_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP7_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP7_OPTIONS_FORM_HELP);
    endif;

    suppressif ideqvallist SETUP_VOLATILE_DATA.PcieControllerCfg2 == 2 3;
      goto PCH_PCIERP8_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP8_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP8_OPTIONS_FORM_HELP);
    endif;

    //
    // Controller 3: Port 9 - 12
    //
    suppressif ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 9;
      goto PCH_PCIERP9_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP9_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP9_OPTIONS_FORM_HELP);
    endif;

    suppressif (NOT ideqval SETUP_VOLATILE_DATA.PcieControllerCfg3 == 0) OR
               (ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 10);
      goto PCH_PCIERP10_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP10_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP10_OPTIONS_FORM_HELP);
    endif;

    suppressif
              (ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds) OR
              (ideqval SETUP_VOLATILE_DATA.PcieControllerCfg3 == 3);
      goto PCH_PCIERP11_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP11_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP11_OPTIONS_FORM_HELP);
    endif;

    suppressif (ideqvallist SETUP_VOLATILE_DATA.PcieControllerCfg3 == 2 3) OR
               (ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 12);
      goto PCH_PCIERP12_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP12_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP12_OPTIONS_FORM_HELP);
    endif;

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
      //
      // Controller 4: Port 13 - 16, SPT-H only
      //
      suppressif ideqval SETUP_VOLATILE_DATA.GbePciePortNum == 13;
        goto PCH_PCIERP13_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP13_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP13_OPTIONS_FORM_HELP);
      endif;

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieControllerCfg4 == 0;
        goto PCH_PCIERP14_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP14_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP14_OPTIONS_FORM_HELP);
      endif;

      suppressif ideqval SETUP_VOLATILE_DATA.PcieControllerCfg4 == 3;
        goto PCH_PCIERP15_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP15_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP15_OPTIONS_FORM_HELP);
      endif;

      suppressif ideqvallist SETUP_VOLATILE_DATA.PcieControllerCfg4 == 2 3;
        goto PCH_PCIERP16_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP16_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP16_OPTIONS_FORM_HELP);
      endif;

      //
      // Controller 5: Port 17 - 20, SPT-H only
      //
      goto PCH_PCIERP17_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP17_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP17_OPTIONS_FORM_HELP);

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieControllerCfg5 == 0;
        goto PCH_PCIERP18_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP18_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP18_OPTIONS_FORM_HELP);
      endif;

      suppressif ideqval SETUP_VOLATILE_DATA.PcieControllerCfg5 == 3;
        goto PCH_PCIERP19_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP19_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP19_OPTIONS_FORM_HELP);
      endif;

      suppressif ideqvallist SETUP_VOLATILE_DATA.PcieControllerCfg5 == 2 3;
        goto PCH_PCIERP20_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP20_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP20_OPTIONS_FORM_HELP);
      endif;

      //
      // Controller 6: Port 21 - 24, KBP-H only
      //
      goto PCH_PCIERP21_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_PCIERP21_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_PCIERP21_OPTIONS_FORM_HELP);

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieControllerCfg6 == 0;
        goto PCH_PCIERP22_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP22_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP22_OPTIONS_FORM_HELP);
      endif;

      suppressif ideqval SETUP_VOLATILE_DATA.PcieControllerCfg6 == 3;
        goto PCH_PCIERP23_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP23_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP23_OPTIONS_FORM_HELP);
      endif;

      suppressif ideqvallist SETUP_VOLATILE_DATA.PcieControllerCfg6 == 2 3;
        goto PCH_PCIERP24_OPTIONS_FORM_ID,
            prompt = STRING_TOKEN(STR_PCIERP24_OPTIONS_FORM_TITLE),
            help = STRING_TOKEN(STR_PCIERP24_OPTIONS_FORM_HELP);
      endif;

    endif; // NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad

  endform; //End of PCIE_DEVICE_OPTIONS_FORM_ID





  form formid = AUTO_ID(USB_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_USB_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_USB_OPTIONS_FORM_SUBTITLE))
    SEPARATOR

    suppressif ideqval SETUP_VOLATILE_DATA.UsbSsicEnabled[0] == 0;
      oneof varid   = PCH_SETUP.UsbSsicEnable[0],
        prompt      = STRING_TOKEN(STR_USB_SSIC_1_SUPPORT),
        help        = STRING_TOKEN(STR_USB_SSIC_SUPPORT_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;
    endif;
    suppressif ideqval SETUP_VOLATILE_DATA.UsbSsicEnabled[1] == 0;
      oneof varid   = PCH_SETUP.UsbSsicEnable[1],
        prompt      = STRING_TOKEN(STR_USB_SSIC_2_SUPPORT),
        help        = STRING_TOKEN(STR_USB_SSIC_SUPPORT_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;
    endif;

    SEPARATOR

    oneof varid   = PCH_SETUP.DisableComplianceMode,
      prompt      = STRING_TOKEN(STR_PCH_XHCI_COMPLIANCE_PROMPT),
      help        = STRING_TOKEN(STR_PCH_XHCI_COMPLIANCE_HELP),
      option text = STRING_TOKEN(STR_FALSE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRUE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    SEPARATOR

    oneof varid   = PCH_SETUP.PchXdciSupport,
      prompt      = STRING_TOKEN(STR_PCH_XDCI_SUPPORT_PROMPT),
      help        = STRING_TOKEN(STR_PCH_XDCI_SUPPORT_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
    endoneof;

    SEPARATOR

    //
    // Usb ports per-port disable control enable
    //
    oneof varid  = PCH_SETUP.PchUsbPortDisable,
      prompt   = STRING_TOKEN(STR_PCH_USB_PORT_TERM_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_TERM_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                   ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_PCH_USB_PORT_TERM_PER_PORT), value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PchUsbPortDisable == 0x0;

    oneof varid  = PCH_SETUP.PchUsbSsPort[0],
      prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT0_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    oneof varid  = PCH_SETUP.PchUsbSsPort[1],
      prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT1_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

    suppressif ideqval SETUP_VOLATILE_DATA.OrgPlatId == BoardIdKabylakeRDdr4;
      oneof varid  = PCH_SETUP.PchUsbSsPort[2],
        prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT2_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdKabylakeRDdr4
                                                                     ? 0x1:0x0), defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid  = PCH_SETUP.PchUsbSsPort[3],
      prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT3_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    oneof varid  = PCH_SETUP.PchUsbSsPort[4],
      prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT4_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    suppressif ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
      oneof varid  = PCH_SETUP.PchUsbSsPort[5],
        prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT5_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;
    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
      oneof varid  = PCH_SETUP.PchUsbSsPort[6],
        prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT6_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
      oneof varid  = PCH_SETUP.PchUsbSsPort[7],
        prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT7_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      oneof varid  = PCH_SETUP.PchUsbSsPort[8],
        prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT8_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
      oneof varid  = PCH_SETUP.PchUsbSsPort[9],
        prompt   = STRING_TOKEN(STR_PCH_USB_SS_PORT9_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid  = PCH_SETUP.PchUsbHsPort[0],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT0_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    oneof varid  = PCH_SETUP.PchUsbHsPort[1],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT1_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    oneof varid  = PCH_SETUP.PchUsbHsPort[2],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT2_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    oneof varid  = PCH_SETUP.PchUsbHsPort[3],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT3_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    oneof varid  = PCH_SETUP.PchUsbHsPort[4],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT4_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    oneof varid  = PCH_SETUP.PchUsbHsPort[5],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT5_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                   ? 0x1:0x0), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;
    oneof varid  = PCH_SETUP.PchUsbHsPort[6],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT6_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                   ? 0x1:0x0), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;
    suppressif ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
      oneof varid  = PCH_SETUP.PchUsbHsPort[7],
        prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT7_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
// AMI_OVERRIDE_START
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                     ? 0x1:0x0), defaultstore = MyStandardDefault,
//          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        endoneof;
    endif;
    oneof varid  = PCH_SETUP.PchUsbHsPort[8],
      prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT8_PROMPT),
      help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                   ? 0x1:0x0), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;
    suppressif ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
      oneof varid  = PCH_SETUP.PchUsbHsPort[9],
        prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT9_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
// AMI_OVERRIDE_START
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                     ? 0x1:0x0), defaultstore = MyStandardDefault,
//          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        endoneof;
    endif;
    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
      oneof varid  = PCH_SETUP.PchUsbHsPort[10],
        prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT10_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      oneof varid  = PCH_SETUP.PchUsbHsPort[11],
        prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT11_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      oneof varid  = PCH_SETUP.PchUsbHsPort[12],
        prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT12_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      oneof varid  = PCH_SETUP.PchUsbHsPort[13],
        prompt   = STRING_TOKEN(STR_PCH_USB_HS_PORT13_PROMPT),
        help     = STRING_TOKEN(STR_PCH_USB_PORT_DIS_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
    endif;
    endif;

    suppressif NOT ideqval SETUP_DATA.SensorHubType == 2;
    SEPARATOR
      oneof varid   = SETUP_DATA.UsbSensorHub,
        prompt      = STRING_TOKEN(STR_USB_SENSOR_HUB_SUPPORT),
        help        = STRING_TOKEN(STR_USB_SENSOR_HUB_SUPPORT_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

  endform; //end of USB_OPTIONS_FORM_ID




  form formid = AUTO_ID(SATA_DEVICE_OPTIONS_FORM_ID),
    title  = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_TITLE);  // note formid is a variable (for readability) (UINT16) - also added Form to the line to signify the Op-Code

    SUBTITLE(STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_SUBTITLE))
    SEPARATOR

    oneof varid = PCH_SETUP.PchSata,
        prompt   = STRING_TOKEN(STR_PCH_SATA_PROMPT),
        help     = STRING_TOKEN(STR_PCH_SATA_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv
//                                                                     ? 0x1:0x0), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags =  RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PchSata == 0;
      oneof varid       = PCH_SETUP.SataInterfaceMode,
        prompt   = STRING_TOKEN(STR_SATA_MODE_SELECTION_PROMPT),
        help     = STRING_TOKEN(STR_SATA_MODE_SELECTION_HELP),

        option text = STRING_TOKEN(STR_SATA_AHCI),  value = SATA_MODE_AHCI, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;

      suppressif ideqval SETUP_VOLATILE_DATA.RstAvailable == 0;
        option text = STRING_TOKEN(STR_SATA_RAID),  value = SATA_MODE_RAID, flags = RESET_REQUIRED;
      endif
      endoneof;

      suppressif NOT ideqval PCH_SETUP.SataInterfaceMode == SATA_MODE_RAID;
  //Rst remapping menu

           grayoutif ideqval SETUP_VOLATILE_DATA.CycleRouterMap[0] == 99;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[0] == 4    AND
                        NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[0] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[2] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[0] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[0],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT0),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[2] == 2;
               grayoutif  ideqval PCH_SETUP.RstPcieRemapEnabled[0] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[2] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[2],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT2),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;
           endif;

           grayoutif ideqval SETUP_VOLATILE_DATA.CycleRouterMap[1] == 99;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[4] == 4    AND
                        NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[4] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[6] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[4] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[4],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT4),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

             suppressif  NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[6] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[4] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[6] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[6],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT6),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

           endif;

           grayoutif ideqval SETUP_VOLATILE_DATA.CycleRouterMap[2] == 99;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[8] == 4    AND
                        NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[8] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[10] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[8] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[8],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT8),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

             suppressif  NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[10] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[8] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[10] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[10],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT10),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

           endif;

           grayoutif ideqval SETUP_VOLATILE_DATA.CycleRouterMap[3] == 99;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[12] == 4    AND
                        NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[12] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[14] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[12] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[12],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT12),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

             suppressif  NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[14] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[12] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[14] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[14],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT14),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;
           endif;

           grayoutif ideqval SETUP_VOLATILE_DATA.CycleRouterMap[4] == 99;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[16] == 4    AND
                        NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[16] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[18] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[16] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[16],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT16),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

             suppressif  NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[18] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[16] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[18] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[18],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT18),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

           endif;

           grayoutif ideqval SETUP_VOLATILE_DATA.CycleRouterMap[5] == 99;

             suppressif NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[20] == 4    AND
                        NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[20] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[22] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[20] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[20],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT20),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;

             suppressif  NOT ideqval SETUP_VOLATILE_DATA.PcieStorageMap[22] == 2;
               grayoutif ideqval PCH_SETUP.RstPcieRemapEnabled[20] == 1 OR
                         ideqval SETUP_VOLATILE_DATA.PcieStorageProgrammingInterface[22] == 0;
               oneof varid    = PCH_SETUP.RstPcieRemapEnabled[22],
                 prompt      = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_PORT22),
                 help        = STRING_TOKEN(STR_RST_PCIE_STORAGE_REMAP_HELP),
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_CONTROLLED), value = 1, flags = RESET_REQUIRED;
                 option text = STRING_TOKEN(STR_RST_PCIE_RST_NOT_CONTROLLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
               endoneof;
               endif;
             endif;
           endif;
      endif;

      oneof varid       = PCH_SETUP.SataTestMode,
        prompt   = STRING_TOKEN(STR_SATA_TEST_MODE_PROMPT),
        help     = STRING_TOKEN(STR_SATA_TEST_MODE_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

    suppressif NOT ideqval PCH_SETUP.SataInterfaceMode == SATA_MODE_RAID;
#if 0  // AMI_OVERRIDE_START
      oneof varid       = SETUP_DATA.EfiRaid,
        prompt   = STRING_TOKEN(STR_SATA_EFI_RAID_PROMPT),
        help     = STRING_TOKEN(STR_SATA_EFI_RAID_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
#endif  // AMI_OVERRIDE_END
      oneof varid = PCH_SETUP.RaidDeviceId,
        prompt   = STRING_TOKEN(STR_RAID_DEV_ID_PROMPT),
        help     = STRING_TOKEN(STR_RAID_DEV_ID_HELP),
        option text = STRING_TOKEN(STR_RAID_DEV_ID_CLIENT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_RAID_DEV_ID_ALTERNATE), value = 1, flags = RESET_REQUIRED;
        suppressif NOT ideqval SETUP_VOLATILE_DATA.PchSku == 2;
          option text = STRING_TOKEN(STR_RAID_DEV_ID_SERVER), value = 2, flags = RESET_REQUIRED;
        endif;
      endoneof;
    endif;

    suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
      goto PCH_SATA_SFMS_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM),
        help = STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM_HELP);

      oneof varid       = PCH_SETUP.SataSalp,
          prompt   = STRING_TOKEN(STR_SATA_AHCI_SALP),
          help     = STRING_TOKEN(STR_SATA_AHCI_SALP_HELP),
// AMI_OVERRIDE_START	
//          default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb ? 0x1:0x0), defaultstore = MyStandardDefault,  // AdvancedFeaturesContent
// AMI_OVERRIDE_END	
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;
//ray_override / [XI-Tuning] Arrange Setup Default Setting

// AMI_OVERRIDE_START >>> Add the SATA Controller Speed
      oneof varid      = PCH_SETUP.SataControllerSpeed,
          prompt       = STRING_TOKEN (STR_SATA_SPEED),
          help         = STRING_TOKEN (STR_SATA_SPEED_HELP),
          option text  = STRING_TOKEN (STR_SATA_SPEED_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text  = STRING_TOKEN (STR_SATA_SPEED_GEN1), value = 1, flags = RESET_REQUIRED;
          option text  = STRING_TOKEN (STR_SATA_SPEED_GEN2), value = 2, flags = RESET_REQUIRED;
          option text  = STRING_TOKEN (STR_SATA_SPEED_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;
// AMI_OVERRIDE_END <<<    

    SEPARATOR

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SATA0_STRING),
      text   = STRING_TOKEN(STR_SATA0_NAME),
      flags  = 0,
      key    = 0;

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SOFT_PRESERVE),
      text   = STRING_TOKEN(STR_SATA0_SOFT_PRESERVE_STATUS),
      flags  = 0,
      key    = 0;

    suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
      oneof varid   = PCH_SETUP.SataPort[0],
        prompt      = STRING_TOKEN(STR_SATA_PORT_0),
        help        = STRING_TOKEN(STR_SATA_PORT_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval PCH_SETUP.SataExternal[0] == 1;
      oneof varid   = PCH_SETUP.SataHotPlug[0],
        prompt      = STRING_TOKEN(STR_SATA_HOTPLUG0),
        help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

     text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA_ESATA),
        text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
        flags  = 0,
        key    = 0;
    endif;

    suppressif ideqval PCH_SETUP.SataHotPlug[0] == 0
               OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[0] == 0;
      oneof varid   = PCH_SETUP.SataMechanicalSw[0],
        prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW0),
        help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid   = PCH_SETUP.SataSpinUp[0],
      prompt      = STRING_TOKEN(STR_SATA_SPIN_UP0),
      help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.SataType[0],
      prompt      = STRING_TOKEN(STR_SATA_TYPE0),
      help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
      option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = PCH_SETUP.SataTopology[0],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY0),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
// AMI_OVERRIDE_START
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeULpddr3Rvp5 BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeLpdimmDoe BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeAioRvp10Erb BoardIdSkylakeAioRvp9Crb BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
       ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeA0Rvp3 BoardIdSkylakeYRvp13 BoardIdAmberLakeLpddr3Rvp13
                ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeURvp7 BoardIdSkylakeURvp7Ppv BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3 BoardIdKabylakeKcDdr3
                  ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeSdlBrk
                                                                   BoardIdKabylakeDdr4Rvp17 // KblGContent
             ? 0x0:0x4):0x3):0x2):0x1), defaultstore = MyStandardDefault,
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//#endif
// AMI_OVERRIDE_END       
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

    oneof varid   = PCH_SETUP.PxDevSlp[0],
      prompt      = STRING_TOKEN(STR_PCH_P0DEVSLP_PROMPT),
      help        = STRING_TOKEN(STR_PCH_P0DEVSLP_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                         ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.EnableDitoConfig[0],
      prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG0_PROMPT),
      help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    grayoutif ideqval PCH_SETUP.EnableDitoConfig[0] == 0;
      numeric varid = PCH_SETUP.DitoVal[0],
        prompt      = STRING_TOKEN(STR_PCH_DITO_VAL0_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 1023,
        step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default     = 625,  // 625 by default
      endnumeric;

      numeric varid   = PCH_SETUP.DmVal[0],
        prompt      = STRING_TOKEN(STR_PCH_DM_VAL0_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default     = 15,    // 15 by default
      endnumeric;
    endif;

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SATA1_STRING),
      text   = STRING_TOKEN(STR_SATA1_NAME),
      flags  = 0,
      key    = 0;

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SOFT_PRESERVE),
      text   = STRING_TOKEN(STR_SATA1_SOFT_PRESERVE_STATUS),
      flags  = 0,
      key    = 0;

    suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
      oneof varid   = PCH_SETUP.SataPort[1],
        prompt      = STRING_TOKEN(STR_SATA_PORT_1),
        help        = STRING_TOKEN(STR_SATA_PORT_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval PCH_SETUP.SataExternal[1] == 1;
      oneof varid   = PCH_SETUP.SataHotPlug[1],
        prompt      = STRING_TOKEN(STR_SATA_HOTPLUG1),
        help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA_ESATA),
        text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
        flags  = 0,
        key    = 0;
    endif;

    suppressif ideqval PCH_SETUP.SataHotPlug[1] == 0
              OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[1] == 0;
      oneof varid   = PCH_SETUP.SataMechanicalSw[1],
        prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW1),
        help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid   = PCH_SETUP.SataSpinUp[1],
      prompt      = STRING_TOKEN(STR_SATA_SPIN_UP1),
      help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.SataType[1],
      prompt      = STRING_TOKEN(STR_SATA_TYPE1),
      help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
      option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = PCH_SETUP.SataTopology[1],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY1),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeLpdimmDoe BoardIdSkylakeULpddr3Rvp5 BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeAioRvp10Erb BoardIdSkylakeAioRvp9Crb BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
                                                                      BoardIdKabylakeDdr4Rvp17 // KblGContent
       ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeURvp7 BoardIdSkylakeURvp15 BoardIdSkylakeURvp7Ppv BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3 BoardIdKabylakeKcDdr3
                  ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeA0Rvp3 BoardIdSkylakeYRvp13 BoardIdAmberLakeLpddr3Rvp13 BoardIdSkylakeSds BoardIdSkylakeSdlBrk
             ? 0x0:0x4):0x2):0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END       
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

    oneof varid   = PCH_SETUP.PxDevSlp[1],
      prompt      = STRING_TOKEN(STR_PCH_P1DEVSLP_PROMPT),
      help        = STRING_TOKEN(STR_PCH_P1DEVSLP_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                         ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.EnableDitoConfig[1],
      prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG1_PROMPT),
      help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    grayoutif ideqval PCH_SETUP.EnableDitoConfig[1] == 0;
      numeric varid = PCH_SETUP.DitoVal[1],
        prompt      = STRING_TOKEN(STR_PCH_DITO_VAL1_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 1023,
        step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default     = 625,  // 625 by default
      endnumeric;

      numeric varid   = PCH_SETUP.DmVal[1],
        prompt      = STRING_TOKEN(STR_PCH_DM_VAL1_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default     = 15,   // 15 by default
      endnumeric;
    endif;

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SATA2_STRING),
      text   = STRING_TOKEN(STR_SATA2_NAME),
      flags  = 0,
      key    = 0;

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SOFT_PRESERVE),
      text   = STRING_TOKEN(STR_SATA2_SOFT_PRESERVE_STATUS),
      flags  = 0,
      key    = 0;

    suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
      oneof varid   = PCH_SETUP.SataPort[2],
        prompt      = STRING_TOKEN(STR_SATA_PORT_2),
        help        = STRING_TOKEN(STR_SATA_PORT_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval PCH_SETUP.SataExternal[2] == 1;
      oneof varid   = PCH_SETUP.SataHotPlug[2],
        prompt      = STRING_TOKEN(STR_SATA_HOTPLUG2),
        help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA_ESATA),
        text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
        flags  = 0,
        key    = 0;
    endif;

    suppressif ideqval PCH_SETUP.SataHotPlug[2] == 0
              OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[2] == 0;
      oneof varid   = PCH_SETUP.SataMechanicalSw[2],
        prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW2),
        help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid   = PCH_SETUP.SataSpinUp[2],
      prompt      = STRING_TOKEN(STR_SATA_SPIN_UP2),
      help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.SataType[2],
      prompt      = STRING_TOKEN(STR_SATA_TYPE2),
      help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
      option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = PCH_SETUP.SataTopology[2],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY2),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeAioRvp10Erb BoardIdSkylakeAioRvp9Crb BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
                                                                      BoardIdKabylakeDdr4Rvp17 // KblGContent
             ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSdlBrk
             ? 0x0:0x4):0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

    oneof varid   = PCH_SETUP.PxDevSlp[2],
      prompt      = STRING_TOKEN(STR_PCH_P2DEVSLP_PROMPT),
      help        = STRING_TOKEN(STR_PCH_P2DEVSLP_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
//                         ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.EnableDitoConfig[2],
      prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG2_PROMPT),
      help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    grayoutif ideqval PCH_SETUP.EnableDitoConfig[2] == 0;
      numeric varid = PCH_SETUP.DitoVal[2],
        prompt      = STRING_TOKEN(STR_PCH_DITO_VAL2_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 1023,
        step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default value = 625,
      endnumeric;

      numeric varid   = PCH_SETUP.DmVal[2],
        prompt      = STRING_TOKEN(STR_PCH_DM_VAL2_PROMPT),
        help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
        default     = 15,   // 15 by default
      endnumeric;
    endif;

    //
    // Port 3 to 7 only in Traditional
    //
    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA3_STRING),
        text   = STRING_TOKEN(STR_SATA3_NAME),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SOFT_PRESERVE),
        text   = STRING_TOKEN(STR_SATA3_SOFT_PRESERVE_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
        oneof varid   = PCH_SETUP.SataPort[3],
          prompt      = STRING_TOKEN(STR_SATA_PORT_3),
          help        = STRING_TOKEN(STR_SATA_PORT_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.SataExternal[3] == 1;
        oneof varid   = PCH_SETUP.SataHotPlug[3],
          prompt      = STRING_TOKEN(STR_SATA_HOTPLUG3),
          help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

        text
          help   = STRING_TOKEN(STR_EMPTY_STRING),
          text   = STRING_TOKEN(STR_SATA_ESATA),
          text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
          flags  = 0,
          key    = 0;
      endif;

      suppressif ideqval PCH_SETUP.SataHotPlug[3] == 0
                OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[3] == 0;
        oneof varid   = PCH_SETUP.SataMechanicalSw[3],
          prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW3),
          help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = PCH_SETUP.SataSpinUp[3],
        prompt      = STRING_TOKEN(STR_SATA_SPIN_UP3),
        help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataType[3],
        prompt      = STRING_TOKEN(STR_SATA_TYPE3),
        help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
        option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = PCH_SETUP.SataTopology[3],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY3),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeAioRvp10Erb BoardIdSkylakeAioRvp9Crb BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
                       ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeHaloDdr4Rvp11
                                                                        BoardIdKabylakeDdr4Rvp17 // KblGContent
                       ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSdlBrk
                       ? 0x0:0x4):0x3):0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

      oneof varid   = PCH_SETUP.PxDevSlp[3],
          prompt      = STRING_TOKEN(STR_PCH_P3DEVSLP_PROMPT),
          help        = STRING_TOKEN(STR_PCH_P3DEVSLP_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

      oneof varid   = PCH_SETUP.EnableDitoConfig[3],
        prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG3_PROMPT),
        help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval PCH_SETUP.EnableDitoConfig[3] == 0;
        numeric varid = PCH_SETUP.DitoVal[3],
          prompt      = STRING_TOKEN(STR_PCH_DITO_VAL3_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 1023,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 625,  // 625 by default
        endnumeric;

        numeric varid   = PCH_SETUP.DmVal[3],
          prompt      = STRING_TOKEN(STR_PCH_DM_VAL3_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 15,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
         default     = 15,   // 15 by default
        endnumeric;
      endif;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA4_STRING),
        text   = STRING_TOKEN(STR_SATA4_NAME),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SOFT_PRESERVE),
        text   = STRING_TOKEN(STR_SATA4_SOFT_PRESERVE_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
        oneof varid   = PCH_SETUP.SataPort[4],
          prompt      = STRING_TOKEN(STR_SATA_PORT_4),
          help        = STRING_TOKEN(STR_SATA_PORT_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.SataExternal[4] == 1;
        oneof varid   = PCH_SETUP.SataHotPlug[4],
          prompt      = STRING_TOKEN(STR_SATA_HOTPLUG4),
          help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

        text
          help   = STRING_TOKEN(STR_EMPTY_STRING),
          text   = STRING_TOKEN(STR_SATA_ESATA),
          text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
          flags  = 0,
          key    = 0;
      endif;

      suppressif ideqval PCH_SETUP.SataHotPlug[4] == 0
                  OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[4] == 0;
        oneof varid   = PCH_SETUP.SataMechanicalSw[4],
          prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW4),
          help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = PCH_SETUP.SataSpinUp[4],
        prompt      = STRING_TOKEN(STR_SATA_SPIN_UP4),
        help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataType[4],
        prompt      = STRING_TOKEN(STR_SATA_TYPE4),
        help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
        option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataTopology[4],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY4),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeAioRvp10Crb BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeAioRvp10Erb
                                                                      BoardIdKabylakeDdr4Rvp17 // KblGContent
             ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSdlBrk BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
             ? 0x0:0x1):0x4), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

     oneof varid   = PCH_SETUP.PxDevSlp[4],
        prompt      = STRING_TOKEN(STR_PCH_P4DEVSLP_PROMPT),
        help        = STRING_TOKEN(STR_PCH_P4DEVSLP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.EnableDitoConfig[4],
        prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG4_PROMPT),
        help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval PCH_SETUP.EnableDitoConfig[4] == 0;
        numeric varid = PCH_SETUP.DitoVal[4],
          prompt      = STRING_TOKEN(STR_PCH_DITO_VAL4_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 1023,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 625,  // 625 by default
        endnumeric;

        numeric varid   = PCH_SETUP.DmVal[4],
          prompt      = STRING_TOKEN(STR_PCH_DM_VAL4_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 15,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 15,   // 15 by default
        endnumeric;
      endif;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA5_STRING),
        text   = STRING_TOKEN(STR_SATA5_NAME),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SOFT_PRESERVE),
        text   = STRING_TOKEN(STR_SATA5_SOFT_PRESERVE_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
        oneof varid   = PCH_SETUP.SataPort[5],
          prompt      = STRING_TOKEN(STR_SATA_PORT_5),
          help        = STRING_TOKEN(STR_SATA_PORT_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.SataExternal[5] == 1;
        oneof varid   = PCH_SETUP.SataHotPlug[5],
          prompt      = STRING_TOKEN(STR_SATA_HOTPLUG5),
          help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

        text
          help   = STRING_TOKEN(STR_EMPTY_STRING),
          text   = STRING_TOKEN(STR_SATA_ESATA),
          text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
          flags  = 0,
          key    = 0;
      endif;

      suppressif ideqval PCH_SETUP.SataHotPlug[5] == 0
                OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[5] == 0;
        oneof varid   = PCH_SETUP.SataMechanicalSw[5],
          prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW5),
          help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = PCH_SETUP.SataSpinUp[5],
        prompt      = STRING_TOKEN(STR_SATA_SPIN_UP5),
        help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataType[5],
        prompt      = STRING_TOKEN(STR_SATA_TYPE5),
        help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
        option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = PCH_SETUP.SataTopology[5],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY5),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeLpdimmDoe BoardIdSkylakeULpddr3Rvp5 BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7 BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3 BoardIdKabylakeKcDdr3 BoardIdSkylakeURvp15 BoardIdSkylakeURvp7Ppv
             ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSdlBrk BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
             ? 0x0:0x1):0x4), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

     oneof varid    = PCH_SETUP.PxDevSlp[5],
        prompt      = STRING_TOKEN(STR_PCH_P5DEVSLP_PROMPT),
        help        = STRING_TOKEN(STR_PCH_P5DEVSLP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.EnableDitoConfig[5],
        prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG5_PROMPT),
        help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval PCH_SETUP.EnableDitoConfig[5] == 0;
        numeric varid = PCH_SETUP.DitoVal[5],
          prompt      = STRING_TOKEN(STR_PCH_DITO_VAL5_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 1023,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 625,  // 625 by default
        endnumeric;

        numeric varid = PCH_SETUP.DmVal[5],
          prompt      = STRING_TOKEN(STR_PCH_DM_VAL5_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 15,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 15,   // 15 by default
        endnumeric;
      endif;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA6_STRING),
        text   = STRING_TOKEN(STR_SATA6_NAME),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SOFT_PRESERVE),
        text   = STRING_TOKEN(STR_SATA6_SOFT_PRESERVE_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqvallist  PCH_SETUP.SataTestMode == SATA_TEST_MODE_ENABLE;
        oneof varid   = PCH_SETUP.SataPort[6],
          prompt      = STRING_TOKEN(STR_SATA_PORT_6),
          help        = STRING_TOKEN(STR_SATA_PORT_HELP),
          default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSdlBrk
                 ? 0x1:0x0), defaultstore = MyStandardDefault,
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.SataExternal[6] == 1;
        oneof varid   = PCH_SETUP.SataHotPlug[6],
          prompt      = STRING_TOKEN(STR_SATA_HOTPLUG6),
          help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

        text
          help   = STRING_TOKEN(STR_EMPTY_STRING),
          text   = STRING_TOKEN(STR_SATA_ESATA),
          text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
          flags  = 0,
          key    = 0;
      endif;

      suppressif ideqval PCH_SETUP.SataHotPlug[6] == 0
                OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[6] == 0;
        oneof varid   = PCH_SETUP.SataMechanicalSw[6],
          prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW6),
          help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = PCH_SETUP.SataSpinUp[6],
        prompt      = STRING_TOKEN(STR_SATA_SPIN_UP6),
        help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataType[6],
        prompt      = STRING_TOKEN(STR_SATA_TYPE6),
        help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
        option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = PCH_SETUP.SataTopology[6],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY6),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
// AMI_OVERRIDE_START	
//       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
//             ? 0x0:0x1), defaultstore = MyStandardDefault,   
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

     oneof varid   = PCH_SETUP.PxDevSlp[6],
        prompt      = STRING_TOKEN(STR_PCH_P6DEVSLP_PROMPT),
        help        = STRING_TOKEN(STR_PCH_P6DEVSLP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.EnableDitoConfig[6],
        prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG6_PROMPT),
        help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval PCH_SETUP.EnableDitoConfig[6] == 0;
        numeric varid = PCH_SETUP.DitoVal[6],
          prompt      = STRING_TOKEN(STR_PCH_DITO_VAL6_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 1023,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 625,  // 625 by default
        endnumeric;

        numeric varid = PCH_SETUP.DmVal[6],
          prompt      = STRING_TOKEN(STR_PCH_DM_VAL6_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 15,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 15,   // 15 by default
        endnumeric;
      endif;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SATA7_STRING),
        text   = STRING_TOKEN(STR_SATA7_NAME),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_SOFT_PRESERVE),
        text   = STRING_TOKEN(STR_SATA7_SOFT_PRESERVE_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqvallist  PCH_SETUP.SataTestMode ==  SATA_TEST_MODE_ENABLE;
        oneof varid   = PCH_SETUP.SataPort[7],
          prompt      = STRING_TOKEN(STR_SATA_PORT_7),
          help        = STRING_TOKEN(STR_SATA_PORT_HELP),
          default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSdlBrk
                 ? 0x1:0x0), defaultstore = MyStandardDefault,
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.SataExternal[7] == 1;
        oneof varid   = PCH_SETUP.SataHotPlug[7],
          prompt      = STRING_TOKEN(STR_SATA_HOTPLUG7),
          help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

        text
          help   = STRING_TOKEN(STR_EMPTY_STRING),
          text   = STRING_TOKEN(STR_SATA_ESATA),
          text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
          flags  = 0,
          key    = 0;
      endif;

      suppressif ideqval PCH_SETUP.SataHotPlug[7] == 0
                OR ideqval SETUP_VOLATILE_DATA.SataMpsPresent[7] == 0;
        oneof varid   = PCH_SETUP.SataMechanicalSw[7],
          prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW7),
          help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = PCH_SETUP.SataSpinUp[7],
        prompt      = STRING_TOKEN(STR_SATA_SPIN_UP7),
        help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataType[7],
        prompt      = STRING_TOKEN(STR_SATA_TYPE7),
        help        = STRING_TOKEN(STR_SATA_TYPE_HELP),
        option text = STRING_TOKEN(STR_SATA_HDD_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SATA_SSD_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = PCH_SETUP.SataTopology[7],
       prompt = STRING_TOKEN(STR_SATA_TOPOLOGY7),
       help = STRING_TOKEN(STR_SATA_TOPOLOGY_HELP),
// AMI_OVERRIDE_START	
//       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
//             ? 0x0:0x1), defaultstore = MyStandardDefault,       
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_SATA_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_ISATA_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_DIRECT_CONNECT_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_FLEX_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_SATA_M2_STRING), value = 4, flags = RESET_REQUIRED;
endoneof;

     oneof varid   = PCH_SETUP.PxDevSlp[7],
        prompt      = STRING_TOKEN(STR_PCH_P7DEVSLP_PROMPT),
        help        = STRING_TOKEN(STR_PCH_P7DEVSLP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.EnableDitoConfig[7],
        prompt      = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG7_PROMPT),
        help        = STRING_TOKEN(STR_PCH_ENABLE_DITO_CONFIG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval PCH_SETUP.EnableDitoConfig[7] == 0;
        numeric varid = PCH_SETUP.DitoVal[7],
          prompt      = STRING_TOKEN(STR_PCH_DITO_VAL7_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DITO_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 1023,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 625,  // 625 by default
        endnumeric;

        numeric varid   = PCH_SETUP.DmVal[7],
          prompt      = STRING_TOKEN(STR_PCH_DM_VAL7_PROMPT),
          help        = STRING_TOKEN(STR_PCH_DM_VAL_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 15,
          step        = 0,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 15,   // 15 by default
        endnumeric;
      endif;
    endif; //suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
    endif; //suppressif ideqval PCH_SETUP.PchSata == 0;
#if ACOUSTIC_MANAGEMENT_SUPPORT
    SEPARATOR

    oneof varid  = SETUP_DATA.HddAcousticPowerManagement,
      prompt   = STRING_TOKEN(STR_HDD_ACOUSTIC_PM_ENABLE),
      help     = STRING_TOKEN(STR_HDD_ACOUSTIC_PM_ENABLE_HELP),
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.HddAcousticPowerManagement == 0x0;
      oneof varid  = SETUP_DATA.HddAcousticMode,
        prompt   = STRING_TOKEN(STR_HDD_ACOUSTIC_ENABLE),
        help     = STRING_TOKEN(STR_HDD_ACOUSTIC_ENABLE_HELP),
        option text = STRING_TOKEN(STR_BYPASS_STRING), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_QUIET_STRING), value = 0x80, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAXIMUM_PERFORMANCE_STRING), value = 0xFE, flags = RESET_REQUIRED;
      endoneof;
    endif;
#endif
  endform;//end of SATA_DEVICE_OPTIONS_FORM_ID




  form formid = AUTO_ID(PCH_SATA_SFMS_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM_SUBTITLE))
    SEPARATOR

    oneof varid   = PCH_SETUP.SataHddlk,
      prompt      = STRING_TOKEN(STR_PCH_HDDLK_PROMPT),
      help        = STRING_TOKEN(STR_PCH_HDDLK_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = PCH_SETUP.SataLedl,
      prompt      = STRING_TOKEN(STR_PCH_LEDL_PROMPT),
      help        = STRING_TOKEN(STR_PCH_LEDL_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqval PCH_SETUP.SataInterfaceMode == SATA_MODE_RAID;
//AMI_OVERRIDE_START - SataLegacyOrom is suppressed and set to 0 if CsmSupport is 0.
#if defined(CSM_SUPPORT) && (CSM_SUPPORT == 1)
    suppressif ideqval SETUP_DATA.CsmSupport == 0;
#else
    suppressif TRUE;
#endif
//AMI_OVERRIDE_END - SataLegacyOrom is suppressed and set to 0 if CsmSupport is 0.
      oneof varid   = PCH_SETUP.SataLegacyOrom,
        prompt      = STRING_TOKEN(STR_PCH_RST_LEGACY_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RST_LEGACY_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
//AMI_OVERRIDE_START - SataLegacyOrom is suppressed and set to 0 if CsmSupport is 0.
    endif;
//AMI_OVERRIDE_END - SataLegacyOrom is suppressed and set to 0 if CsmSupport is 0.

      oneof varid   = PCH_SETUP.SataRaidR0,
        prompt      = STRING_TOKEN(STR_PCH_RAID0_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RAID0_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidR1,
        prompt      = STRING_TOKEN(STR_PCH_RAID1_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RAID1_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidR10,
        prompt      = STRING_TOKEN(STR_PCH_RAID10_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RAID10_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidR5,
        prompt      = STRING_TOKEN(STR_PCH_RAID5_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RAID5_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidIrrt,
        prompt      = STRING_TOKEN(STR_PCH_IRRT_PROMPT),
        help        = STRING_TOKEN(STR_PCH_IRRT_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidOub,
        prompt      = STRING_TOKEN(STR_PCH_OUB_PROMPT),
        help        = STRING_TOKEN(STR_PCH_OUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidIooe,
        prompt      = STRING_TOKEN(STR_PCH_IOOE_PROMPT),
        help        = STRING_TOKEN(STR_PCH_IOOE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidSrt,
        prompt      = STRING_TOKEN(STR_PCH_SRT_PROMPT),
        help        = STRING_TOKEN(STR_PCH_SRT_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRaidOromDelay,
        prompt      = STRING_TOKEN(STR_PCH_ODLY_PROMPT),
        help        = STRING_TOKEN(STR_PCH_ODLY_HELP),
        option text = STRING_TOKEN(STR_2S_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_4S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_6S_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_8S_STRING), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRstForceForm,
        prompt      = STRING_TOKEN(STR_PCH_RST_FORCE_FORM_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RST_FORCE_FORM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRstOptaneMemory,
        prompt      = STRING_TOKEN(STR_PCH_OPTANE_ACCEL_PROMPT),
        help        = STRING_TOKEN(STR_PCH_OPTANE_ACCEL_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.SataRstCpuAttachedStorage,
        prompt      = STRING_TOKEN(STR_PCH_RST_CPU_ATTACHED_STORAGE_PROMPT),
        help        = STRING_TOKEN(STR_PCH_RST_CPU_ATTACHED_STORAGE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

    endif;

  endform; //End of PCH_SATA_SFMS_OPTIONS_FORM_ID


  form formid = AUTO_ID(PCH_PCIE_LANE_EQ_FORM_ID),  // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_PCIE_LANE_EQ_FORM_TITLE);

    numeric varid = PCH_SETUP.PcieLaneCm[0],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT0),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[0],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT0),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[1],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT1),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[1],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT1),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[2],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT2),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[2],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT2),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[3],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT3),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[3],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT3),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[4],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT4),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[4],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT4),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[5],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT5),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[5],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT5),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[6],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT6),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[6],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT6),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[7],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT7),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[7],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT7),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[8],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT8),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[8],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT8),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[9],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT9),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[9],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT9),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[10],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT10),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[10],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT10),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[11],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT11),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[11],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT11),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[12],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT12),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[12],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT12),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[13],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT13),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[13],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT13),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[14],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT14),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[14],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT14),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[15],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT15),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[15],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT15),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[16],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT16),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[16],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT16),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[17],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT17),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[17],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT17),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[18],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT18),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[18],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT18),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    numeric varid = PCH_SETUP.PcieLaneCm[19],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CM_PROMPT19),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 6,
    endnumeric;
    numeric varid = PCH_SETUP.PcieLaneCp[19],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LANE_CP_PROMPT19),
      help        = STRING_TOKEN (STR_EMPTY_STRING),
      minimum     = 0,
      maximum     = 63,
      step        = 1,
      default     = 2,
    endnumeric;

    SEPARATOR

    oneof varid   = PCH_SETUP.PcieSwEqOverride,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_OVERRIDE_PROMPT),
      help        = STRING_TOKEN(STR_EMPTY_STRING),
      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3
                           ? 0x0:0x1), defaultstore = MyStandardDefault,
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieSwEqOverride == 0;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCm[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF0_CM_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 6,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCp[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF0_CP_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCm[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF1_CM_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 4,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCp[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF1_CP_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCm[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF2_CM_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCp[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF2_CP_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCm[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF3_CM_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCp[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF3_CP_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCm[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF4_CM_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 10,
      endnumeric;
      numeric varid = PCH_SETUP.PcieSwEqCoeffCp[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SW_EQ_COEFF4_CP_PROMPT),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 63,
        step        = 1,
        default     = 2,
      endnumeric;
    endif;

  endform;

  form formid = AUTO_ID(PCH_PCIERP1_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP1_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[0],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP1_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[0] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[0],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY0),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeA0Rvp3 BoardIdSkylakeYRvp13 BoardIdAmberLakeLpddr3Rvp13
             ? 0x0:0x2), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START             
//       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[0],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT1),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3
//                                                                     ? 0x4:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[0],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT1),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3
                             ? 0x3:0x0), defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[0],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT1),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3
                             ? 0x2:0x1), defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[0],
        prompt      = STRING_TOKEN (STR_PCH_PCIE1_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[0],
        prompt      = STRING_TOKEN (STR_PCH_PCIE1_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3
                             ? 7:5),
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[0],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT1),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 1)      
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 


      oneof varid   = PCH_SETUP.PcieRootPortAER[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[0],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT1),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeSds
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[0],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT1),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[0],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT1),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[0],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT1),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[0],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT1),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[0],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT1),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[0],
        prompt   = STRING_TOKEN (STR_PCH_PCIE1_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[0] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[0],
          prompt      = STRING_TOKEN (STR_PCH_PCIE1_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[0] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[0],
            prompt      = STRING_TOKEN(STR_PCH_PCIE1_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[0],
            prompt      = STRING_TOKEN(STR_PCH_PCIE1_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[0],
          prompt      = STRING_TOKEN (STR_PCH_PCIE1_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[0] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[0],
            prompt      = STRING_TOKEN(STR_PCH_PCIE1_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[0],
            prompt      = STRING_TOKEN(STR_PCH_PCIE1_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[0],
          prompt      = STRING_TOKEN(STR_PCH_PCIE1_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[0],
        prompt   = STRING_TOKEN (STR_PCH_PCIE1_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[0],
        prompt   = STRING_TOKEN (STR_PCH_PCIE1_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[0] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[0],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT0),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP01_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<
      
    endif;
  endform; //End of PCH_PCIERP1_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_PCIERP2_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP2_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[1],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP2_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[1] == 0x0;
       oneof varid = PCH_SETUP.PcieTopology[1],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY1),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
       endoneof;
      oneof varid   = PCH_SETUP.PcieRootPortAspm[1],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT2),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x4:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[1],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT2),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[1],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT2),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[1],
        prompt      = STRING_TOKEN (STR_PCH_PCIE2_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[1],
        prompt      = STRING_TOKEN (STR_PCH_PCIE2_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[1],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT2),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 2)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[1],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT2),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeSds
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[1],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT2),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[1],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT2),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 2;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[1],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT2),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[1],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT2),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[1],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT2),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[1],
        prompt   = STRING_TOKEN (STR_PCH_PCIE2_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[1] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[1],
          prompt      = STRING_TOKEN (STR_PCH_PCIE2_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[1] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[1],
            prompt      = STRING_TOKEN(STR_PCH_PCIE2_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[1],
            prompt      = STRING_TOKEN(STR_PCH_PCIE2_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[1],
          prompt      = STRING_TOKEN (STR_PCH_PCIE2_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[1] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[1],
            prompt      = STRING_TOKEN(STR_PCH_PCIE2_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[1],
            prompt      = STRING_TOKEN(STR_PCH_PCIE2_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[1],
          prompt      = STRING_TOKEN(STR_PCH_PCIE2_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[1],
        prompt   = STRING_TOKEN (STR_PCH_PCIE2_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[1],
        prompt   = STRING_TOKEN (STR_PCH_PCIE2_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[1] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[1],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT1),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP02_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP2_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_PCIERP3_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP3_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[2],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP3_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[2] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[2],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY2),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeURvp15 BoardIdSkylakeLpdimmDoe BoardIdSkylakeULpddr3Rvp5 BoardIdSkylakeULpddr3Rvp5Ppv BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3 BoardIdKabylakeKcDdr3 BoardIdSkylakeURvp7 BoardIdSkylakeURvp7Ppv
             ? 0x0:0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
      oneof varid   = PCH_SETUP.PcieRootPortAspm[2],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT3),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x4:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[2],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT3),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[2],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT3),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[2],
        prompt      = STRING_TOKEN (STR_PCH_PCIE3_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[2],
        prompt      = STRING_TOKEN (STR_PCH_PCIE3_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[2],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT3),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 3)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[2],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT3),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeURvp7Ppv BoardIdSkylakeULpddr3Rvp5Ppv 
//                      ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv		
//                                                                     ? 0x0:0x2):0x1), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[2],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT3),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[2],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT3),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 3;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[2],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT3),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[2],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT3),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[2],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT3),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[2],
        prompt   = STRING_TOKEN (STR_PCH_PCIE3_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[2] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[2],
          prompt      = STRING_TOKEN (STR_PCH_PCIE3_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[2] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[2],
            prompt      = STRING_TOKEN(STR_PCH_PCIE3_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[2],
            prompt      = STRING_TOKEN(STR_PCH_PCIE3_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[2],
          prompt      = STRING_TOKEN (STR_PCH_PCIE3_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[2] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[2],
            prompt      = STRING_TOKEN(STR_PCH_PCIE3_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[2],
            prompt      = STRING_TOKEN(STR_PCH_PCIE3_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[2],
          prompt      = STRING_TOKEN(STR_PCH_PCIE3_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[2],
        prompt   = STRING_TOKEN (STR_PCH_PCIE3_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[2],
        prompt   = STRING_TOKEN (STR_PCH_PCIE3_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[2] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[2],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT2),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;

// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP03_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP3_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP4_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP4_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[3],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP4_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
// AMI_OVERRIDE_START	   
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//             ? 0x1:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END 
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[3] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[3],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY3),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeLpdimmDoe BoardIdSkylakeULpddr3Rvp5 BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7 BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3 BoardIdKabylakeKcDdr3 BoardIdSkylakeURvp15 BoardIdSkylakeURvp7Ppv
             ? 0x0:0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
      oneof varid   = PCH_SETUP.PcieRootPortAspm[3],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT4),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x4:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[3],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT4),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[3],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT4),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[3],
        prompt      = STRING_TOKEN (STR_PCH_PCIE4_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[3],
        prompt      = STRING_TOKEN (STR_PCH_PCIE4_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[3],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT4),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 4)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[3],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT4),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[3],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT4),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[3],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT4),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 4;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[3],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT4),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[3],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT4),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[3],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT4),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[3],
        prompt   = STRING_TOKEN (STR_PCH_PCIE4_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[3] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[3],
          prompt      = STRING_TOKEN (STR_PCH_PCIE4_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[3] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[3],
            prompt      = STRING_TOKEN(STR_PCH_PCIE4_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[3],
            prompt      = STRING_TOKEN(STR_PCH_PCIE4_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[3],
          prompt      = STRING_TOKEN (STR_PCH_PCIE4_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[3] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[3],
            prompt      = STRING_TOKEN(STR_PCH_PCIE4_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[3],
            prompt      = STRING_TOKEN(STR_PCH_PCIE4_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[3],
          prompt      = STRING_TOKEN(STR_PCH_PCIE4_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[3],
        prompt   = STRING_TOKEN (STR_PCH_PCIE4_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[3],
        prompt   = STRING_TOKEN (STR_PCH_PCIE4_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[3] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[3],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT3),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP04_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP4_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP5_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP5_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[4],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP5_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeURvp7Ppv
//                                                                   ? 0x1:0x0), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[4] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[4],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY4),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeA0Rvp3 BoardIdSkylakeYRvp13 BoardIdAmberLakeLpddr3Rvp13 BoardIdSkylakeSds
//             ? 0x0:0x4), defaultstore = MyStandardDefault,
//       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[4],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT5),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x4:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[4],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT5),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[4],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT5),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[4],
        prompt      = STRING_TOKEN (STR_PCH_PCIE5_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[4],
        prompt      = STRING_TOKEN (STR_PCH_PCIE5_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[4],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT5),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 5)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[4],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT5),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[4],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT5),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[4],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT5),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 5;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[4],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT5),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[4],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT5),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[4],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT5),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[4],
        prompt   = STRING_TOKEN (STR_PCH_PCIE5_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[4] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[4],
          prompt      = STRING_TOKEN (STR_PCH_PCIE5_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[4] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[4],
            prompt      = STRING_TOKEN(STR_PCH_PCIE5_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[4],
            prompt      = STRING_TOKEN(STR_PCH_PCIE5_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[4],
          prompt      = STRING_TOKEN (STR_PCH_PCIE5_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[4] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[4],
            prompt      = STRING_TOKEN(STR_PCH_PCIE5_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[4],
            prompt      = STRING_TOKEN(STR_PCH_PCIE5_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[4],
          prompt      = STRING_TOKEN(STR_PCH_PCIE5_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[4],
        prompt   = STRING_TOKEN (STR_PCH_PCIE5_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[4],
        prompt   = STRING_TOKEN (STR_PCH_PCIE5_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[4] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[4],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT4),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP05_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP5_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP6_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP6_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[5],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP6_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[5] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[5],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY5),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeA0Rvp3 BoardIdSkylakeYRvp13 BoardIdAmberLakeLpddr3Rvp13
             ? 0x0:0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[5],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT6),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[5],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT6),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[5],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT6),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[5],
        prompt      = STRING_TOKEN (STR_PCH_PCIE6_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[5],
        prompt      = STRING_TOKEN (STR_PCH_PCIE6_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[5],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT6),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 6)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[5],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT6),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                      ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv                                  
//                      ? 0x0:0x2):0x1), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[5],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT6),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[5],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT6),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 6;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[5],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT6),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[5],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT6),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[5],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT6),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[5],
        prompt   = STRING_TOKEN (STR_PCH_PCIE6_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[5] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[5],
          prompt      = STRING_TOKEN (STR_PCH_PCIE6_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[5] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[5],
            prompt      = STRING_TOKEN(STR_PCH_PCIE6_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[5],
            prompt      = STRING_TOKEN(STR_PCH_PCIE6_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[5],
          prompt      = STRING_TOKEN (STR_PCH_PCIE6_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[5] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[5],
            prompt      = STRING_TOKEN(STR_PCH_PCIE6_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[5],
            prompt      = STRING_TOKEN(STR_PCH_PCIE6_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[5],
          prompt      = STRING_TOKEN(STR_PCH_PCIE6_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[5],
        prompt   = STRING_TOKEN (STR_PCH_PCIE6_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[5],
        prompt   = STRING_TOKEN (STR_PCH_PCIE6_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[5] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[5],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT5),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP06_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP6_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP7_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP7_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[6],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP7_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[6] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[6],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY6),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeAioRvp10Erb BoardIdSkylakeAioRvp9Crb
             ? 0x0:0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[6],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT7),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[6],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT7),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[6],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT7),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[6],
        prompt      = STRING_TOKEN (STR_PCH_PCIE7_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[6],
        prompt      = STRING_TOKEN (STR_PCH_PCIE7_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[6],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT7),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 7)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[6],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT7),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[6],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT7),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[6],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT7),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 7;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[6],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT7),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 7,    // Default bus reserved for docking (Saddlestring)
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[6],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT7),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 17,   // Default 17MB Memory Reserved for docking (Saddlestring)
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[6],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT7),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 16,   // Default 16K IO Reserved for docking (Saddlestring)
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[6],
        prompt   = STRING_TOKEN (STR_PCH_PCIE7_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[6] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[6],
          prompt      = STRING_TOKEN (STR_PCH_PCIE7_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[6] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[6],
            prompt      = STRING_TOKEN(STR_PCH_PCIE7_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[6],
            prompt      = STRING_TOKEN(STR_PCH_PCIE7_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[6],
          prompt      = STRING_TOKEN (STR_PCH_PCIE7_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[6] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[6],
            prompt      = STRING_TOKEN(STR_PCH_PCIE7_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[6],
            prompt      = STRING_TOKEN(STR_PCH_PCIE7_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[6],
          prompt      = STRING_TOKEN(STR_PCH_PCIE7_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[6],
        prompt   = STRING_TOKEN (STR_PCH_PCIE7_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[6],
        prompt   = STRING_TOKEN (STR_PCH_PCIE7_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[6] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[6],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT6),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP07_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP7_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP8_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP8_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[7],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP8_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[7] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[7],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY7),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeAioRvp10Erb BoardIdSkylakeAioRvp9Crb
                                                                      BoardIdKabylakeDdr4Rvp17 // KblGContent
             ? 0x0:0x1), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[7],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT8),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[7],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT8),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[7],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT8),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[7],
        prompt      = STRING_TOKEN (STR_PCH_PCIE8_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[7],
        prompt      = STRING_TOKEN (STR_PCH_PCIE8_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[7],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT8),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 8)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[7],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT8),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[7],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT8),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[7],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT8),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 8;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[7],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT8),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 7,    // Default bus reserved for docking (Saddlestring)
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[7],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT8),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 17,   // Default 17MB Memory Reserved for docking (Saddlestring)
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[7],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT8),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 8,    // Default 8K IO Reserved for docking (Saddlestring)
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[7],
        prompt   = STRING_TOKEN (STR_PCH_PCIE8_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[7] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[7],
          prompt      = STRING_TOKEN (STR_PCH_PCIE8_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[7] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[7],
            prompt      = STRING_TOKEN(STR_PCH_PCIE8_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[7],
            prompt      = STRING_TOKEN(STR_PCH_PCIE8_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[7],
          prompt      = STRING_TOKEN (STR_PCH_PCIE8_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[7] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[7],
            prompt      = STRING_TOKEN(STR_PCH_PCIE8_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[7],
            prompt      = STRING_TOKEN(STR_PCH_PCIE8_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[7],
          prompt      = STRING_TOKEN(STR_PCH_PCIE8_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[7],
        prompt   = STRING_TOKEN (STR_PCH_PCIE8_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[7],
        prompt   = STRING_TOKEN (STR_PCH_PCIE8_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[7] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[7],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT7),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP08_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP8_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP9_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP9_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[8],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP9_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
                                                                   ? 0x1:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[8] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[8],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY8),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeAioRvp10Crb BoardIdSkylakeAioRvp10Erb BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeHaloDdr4Rvp11Ppv  BoardIdSkylakeHaloLpddr3Rvp16  BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp9Crb
                                                                     BoardIdKabylakeDdr4Rvp17 // KblGContent
               ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId ==  BoardIdSkylakeLpdimmDoe BoardIdSkylakeULpddr3Rvp5 BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7 BoardIdKabylakeRDdr4 BoardIdKabylakeRLpddr3 BoardIdKabylakeKcDdr3 BoardIdSkylakeURvp7Ppv BoardIdSkylakeURvp15
             ? 0x0:0x4):0x2), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START	     
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[8],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT9),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x4:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[8],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT9),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[8],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT9),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[8],
        prompt      = STRING_TOKEN (STR_PCH_PCIE9_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[8],
        prompt      = STRING_TOKEN (STR_PCH_PCIE9_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[8],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT9),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 9)      
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
// AMI_OVERRIDE_START                        
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                             ? 0x0:0x1), defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END	
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
// AMI_OVERRIDE_START                        
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                             ? 0x0:0x1), defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END	
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif

      oneof varid   = PCH_SETUP.PcieRootPortAER[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[8],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT9),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[8],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT9),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[8],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT9),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[8],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT9),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[8],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT9),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[8],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT9),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[8],
        prompt   = STRING_TOKEN (STR_PCH_PCIE9_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[8] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[8],
          prompt      = STRING_TOKEN (STR_PCH_PCIE9_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[8] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[8],
            prompt      = STRING_TOKEN(STR_PCH_PCIE9_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[8],
            prompt      = STRING_TOKEN(STR_PCH_PCIE9_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[8],
          prompt      = STRING_TOKEN (STR_PCH_PCIE9_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[8] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[8],
            prompt      = STRING_TOKEN(STR_PCH_PCIE9_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[8],
            prompt      = STRING_TOKEN(STR_PCH_PCIE9_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[8],
          prompt      = STRING_TOKEN(STR_PCH_PCIE9_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[8],
        prompt   = STRING_TOKEN (STR_PCH_PCIE9_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[8],
        prompt   = STRING_TOKEN (STR_PCH_PCIE9_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[8] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[8],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT8),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP09_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP9_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP10_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP10_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[9],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP10_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[9] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[9],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY9),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[9],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT10),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[9],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT10),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[9],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT10),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[9],
        prompt      = STRING_TOKEN (STR_PCH_PCIE10_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[9],
        prompt      = STRING_TOKEN (STR_PCH_PCIE10_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[9],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT10),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 10)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[9],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT10),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[9],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT10),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[9],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT10),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[9],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT10),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[9],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT10),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[9],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT10),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[9],
        prompt   = STRING_TOKEN (STR_PCH_PCIE10_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[9] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[9],
          prompt      = STRING_TOKEN (STR_PCH_PCIE10_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[9] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[9],
            prompt      = STRING_TOKEN(STR_PCH_PCIE10_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[9],
            prompt      = STRING_TOKEN(STR_PCH_PCIE10_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[9],
          prompt      = STRING_TOKEN (STR_PCH_PCIE10_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[9] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[9],
            prompt      = STRING_TOKEN(STR_PCH_PCIE10_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[9],
            prompt      = STRING_TOKEN(STR_PCH_PCIE10_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[9],
          prompt      = STRING_TOKEN(STR_PCH_PCIE10_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[9],
        prompt   = STRING_TOKEN (STR_PCH_PCIE10_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[9],
        prompt   = STRING_TOKEN (STR_PCH_PCIE10_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[9] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[9],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT9),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP10_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP10_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP11_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP11_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[10],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP11_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                         ? 0x1:0x0), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[10] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[10],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY10),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[10],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT11),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[10],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT11),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[10],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT11),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[10],
        prompt      = STRING_TOKEN (STR_PCH_PCIE11_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[10],
        prompt      = STRING_TOKEN (STR_PCH_PCIE11_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[10],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT11),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 11)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[10],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT11),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[10],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT11),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[10],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT11),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[10],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT11),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[10],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT11),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[10],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT11),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[10],
        prompt   = STRING_TOKEN (STR_PCH_PCIE11_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[10] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[10],
          prompt      = STRING_TOKEN (STR_PCH_PCIE11_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[10] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[10],
            prompt      = STRING_TOKEN(STR_PCH_PCIE11_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[10],
            prompt      = STRING_TOKEN(STR_PCH_PCIE11_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[10],
          prompt      = STRING_TOKEN (STR_PCH_PCIE11_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[10] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[10],
            prompt      = STRING_TOKEN(STR_PCH_PCIE11_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[10],
            prompt      = STRING_TOKEN(STR_PCH_PCIE11_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[10],
          prompt      = STRING_TOKEN(STR_PCH_PCIE11_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[10],
        prompt   = STRING_TOKEN (STR_PCH_PCIE11_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[10],
        prompt   = STRING_TOKEN (STR_PCH_PCIE11_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[10] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[10],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT10),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP11_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP11_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP12_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP12_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[11],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP12_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[11] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[11],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY11),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[11],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT12),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[11],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT12),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[11],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT12),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[11],
        prompt      = STRING_TOKEN (STR_PCH_PCIE12_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[11],
        prompt      = STRING_TOKEN (STR_PCH_PCIE12_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[11],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT12),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 12)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[11],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT12),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[11],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT12),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[11],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT12),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[11],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT12),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[11],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT12),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[11],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT12),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[11],
        prompt   = STRING_TOKEN (STR_PCH_PCIE12_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[11] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[11],
          prompt      = STRING_TOKEN (STR_PCH_PCIE12_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[11] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[11],
            prompt      = STRING_TOKEN(STR_PCH_PCIE12_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[11],
            prompt      = STRING_TOKEN(STR_PCH_PCIE12_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[11],
          prompt      = STRING_TOKEN (STR_PCH_PCIE12_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[11] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[11],
            prompt      = STRING_TOKEN(STR_PCH_PCIE12_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[11],
            prompt      = STRING_TOKEN(STR_PCH_PCIE12_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[11],
          prompt      = STRING_TOKEN(STR_PCH_PCIE12_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[11],
        prompt   = STRING_TOKEN (STR_PCH_PCIE12_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[11],
        prompt   = STRING_TOKEN (STR_PCH_PCIE12_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[11] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[11],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT11),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP12_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP12_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP13_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP13_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[12],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP13_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[12] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[12],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY12),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeSdlBrk
                                                                      BoardIdKabylakeDdr4Rvp17 // KblGContent
             ? 0x0:0x4), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
       endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[12],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT13),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[12],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT13),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[12],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT13),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[12],
        prompt      = STRING_TOKEN (STR_PCH_PCIE13_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[12],
        prompt      = STRING_TOKEN (STR_PCH_PCIE13_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[12],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT13),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 13)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[12],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT13),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[12],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT13),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[12],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT13),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[12],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT13),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[12],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT13),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[12],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT13),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[12],
        prompt   = STRING_TOKEN (STR_PCH_PCIE13_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[12] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[12],
          prompt      = STRING_TOKEN (STR_PCH_PCIE13_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[12] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[12],
            prompt      = STRING_TOKEN(STR_PCH_PCIE13_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[12],
            prompt      = STRING_TOKEN(STR_PCH_PCIE13_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[12],
          prompt      = STRING_TOKEN (STR_PCH_PCIE13_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[12] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[12],
            prompt      = STRING_TOKEN(STR_PCH_PCIE13_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[12],
            prompt      = STRING_TOKEN(STR_PCH_PCIE13_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[12],
          prompt      = STRING_TOKEN(STR_PCH_PCIE13_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[12],
        prompt   = STRING_TOKEN (STR_PCH_PCIE13_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[12],
        prompt   = STRING_TOKEN (STR_PCH_PCIE13_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[12] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[12],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT12),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP13_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP13_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP14_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP14_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[13],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP14_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[13] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[13],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY13),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[13],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT14),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[13],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT14),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[13],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT14),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[13],
        prompt      = STRING_TOKEN (STR_PCH_PCIE14_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[13],
        prompt      = STRING_TOKEN (STR_PCH_PCIE14_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[13],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT14),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 14)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[13],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT14),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[13],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT14),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[13],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT14),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[13],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT14),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[13],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT14),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[13],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT14),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[13],
        prompt   = STRING_TOKEN (STR_PCH_PCIE14_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[13] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[13],
          prompt      = STRING_TOKEN (STR_PCH_PCIE14_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[13] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[13],
            prompt      = STRING_TOKEN(STR_PCH_PCIE14_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[13],
            prompt      = STRING_TOKEN(STR_PCH_PCIE14_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[13],
          prompt      = STRING_TOKEN (STR_PCH_PCIE14_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[13] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[13],
            prompt      = STRING_TOKEN(STR_PCH_PCIE14_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[13],
            prompt      = STRING_TOKEN(STR_PCH_PCIE14_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[13],
          prompt      = STRING_TOKEN(STR_PCH_PCIE14_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[13],
        prompt   = STRING_TOKEN (STR_PCH_PCIE14_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[13],
        prompt   = STRING_TOKEN (STR_PCH_PCIE14_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[13] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[13],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT13),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP14_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP14_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP15_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP15_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[14],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP15_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[14] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[14],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY14),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[14],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT15),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[14],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT15),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[14],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT15),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[14],
        prompt      = STRING_TOKEN (STR_PCH_PCIE15_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[14],
        prompt      = STRING_TOKEN (STR_PCH_PCIE15_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[14],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT15),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 15)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[14],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT15),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[14],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT15),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[14],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT15),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[14],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT15),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[14],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT15),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[14],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT15),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[14],
        prompt   = STRING_TOKEN (STR_PCH_PCIE15_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[14] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[14],
          prompt      = STRING_TOKEN (STR_PCH_PCIE15_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[14] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[14],
            prompt      = STRING_TOKEN(STR_PCH_PCIE15_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[14],
            prompt      = STRING_TOKEN(STR_PCH_PCIE15_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[14],
          prompt      = STRING_TOKEN (STR_PCH_PCIE15_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[14] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[14],
            prompt      = STRING_TOKEN(STR_PCH_PCIE15_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[14],
            prompt      = STRING_TOKEN(STR_PCH_PCIE15_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[14],
          prompt      = STRING_TOKEN(STR_PCH_PCIE15_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[14],
        prompt   = STRING_TOKEN (STR_PCH_PCIE15_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[14],
        prompt   = STRING_TOKEN (STR_PCH_PCIE15_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[14] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[14],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT14),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP15_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP15_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP16_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP16_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[15],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP16_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[15] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[15],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY15),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[15],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT16),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[15],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT16),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[15],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT16),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[15],
        prompt      = STRING_TOKEN (STR_PCH_PCIE16_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[15],
        prompt      = STRING_TOKEN (STR_PCH_PCIE16_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[15],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT16),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 16)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[15],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT16),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[15],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT16),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[15],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT16),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[15],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT16),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[15],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT16),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[15],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT16),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[15],
        prompt   = STRING_TOKEN (STR_PCH_PCIE16_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[15] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[15],
          prompt      = STRING_TOKEN (STR_PCH_PCIE16_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[15] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[15],
            prompt      = STRING_TOKEN(STR_PCH_PCIE16_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[15],
            prompt      = STRING_TOKEN(STR_PCH_PCIE16_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[15],
          prompt      = STRING_TOKEN (STR_PCH_PCIE16_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[15] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[15],
            prompt      = STRING_TOKEN(STR_PCH_PCIE16_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[15],
            prompt      = STRING_TOKEN(STR_PCH_PCIE16_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[15],
          prompt      = STRING_TOKEN(STR_PCH_PCIE16_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[15],
        prompt   = STRING_TOKEN (STR_PCH_PCIE16_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[15],
        prompt   = STRING_TOKEN (STR_PCH_PCIE16_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[15] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[15],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT15),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP16_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP16_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP17_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP17_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[16],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP17_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[16] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[16],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY16),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeHaloLpddr3Rvp16 BoardIdSkylakeHaloDdr4Rvp11Ppv BoardIdSkylakeHaloDdr4Rvp11 BoardIdSkylakeDtRvp8Crb BoardIdSkylakeAioRvp9Crb BoardIdSkylakeAioRvp10Crb BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeAioRvp10Erb
                                                                      BoardIdKabylakeDdr4Rvp17 // KblGContent
             ? 0x0:0x4), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_START
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
// AMI_OVERRIDE_END
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[16],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT17),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[16],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT17),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[16],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT17),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[16],
        prompt      = STRING_TOKEN (STR_PCH_PCIE17_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[16],
        prompt      = STRING_TOKEN (STR_PCH_PCIE17_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[16],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT17),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 17)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[16],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT17),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[16],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT17),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[16],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT17),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[16],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT17),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[16],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT17),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[16],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT17),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[16],
        prompt   = STRING_TOKEN (STR_PCH_PCIE17_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[16] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[16],
          prompt      = STRING_TOKEN (STR_PCH_PCIE17_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[16] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[16],
            prompt      = STRING_TOKEN(STR_PCH_PCIE17_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[16],
            prompt      = STRING_TOKEN(STR_PCH_PCIE17_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[16],
          prompt      = STRING_TOKEN (STR_PCH_PCIE17_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[16] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[16],
            prompt      = STRING_TOKEN(STR_PCH_PCIE17_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[16],
            prompt      = STRING_TOKEN(STR_PCH_PCIE17_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[16],
          prompt      = STRING_TOKEN(STR_PCH_PCIE17_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[16],
        prompt   = STRING_TOKEN (STR_PCH_PCIE17_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[16],
        prompt   = STRING_TOKEN (STR_PCH_PCIE17_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[16] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[16],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT16),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP17_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP17_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP18_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP18_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[17],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP18_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[17] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[17],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY17),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[17],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT18),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[17],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT18),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[17],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT18),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[17],
        prompt      = STRING_TOKEN (STR_PCH_PCIE18_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[17],
        prompt      = STRING_TOKEN (STR_PCH_PCIE18_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[17],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT18),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 18)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[17],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT18),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[17],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT18),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[17],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT18),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[17],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT18),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[17],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT18),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[17],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT18),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[17],
        prompt   = STRING_TOKEN (STR_PCH_PCIE18_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[17] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[17],
          prompt      = STRING_TOKEN (STR_PCH_PCIE18_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[17] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[17],
            prompt      = STRING_TOKEN(STR_PCH_PCIE18_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[17],
            prompt      = STRING_TOKEN(STR_PCH_PCIE18_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[17],
          prompt      = STRING_TOKEN (STR_PCH_PCIE18_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[17] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[17],
            prompt      = STRING_TOKEN(STR_PCH_PCIE18_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[17],
            prompt      = STRING_TOKEN(STR_PCH_PCIE18_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[17],
          prompt      = STRING_TOKEN(STR_PCH_PCIE18_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[17],
        prompt   = STRING_TOKEN (STR_PCH_PCIE18_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[17],
        prompt   = STRING_TOKEN (STR_PCH_PCIE18_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[17] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[17],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT17),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP18_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP18_OPTIONS_FORM_ID





  form formid = AUTO_ID(PCH_PCIERP19_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP19_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[18],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP19_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[18] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[18],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY18),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[18],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT19),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[18],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT19),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[18],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT19),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[18],
        prompt      = STRING_TOKEN (STR_PCH_PCIE19_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[18],
        prompt      = STRING_TOKEN (STR_PCH_PCIE19_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[18],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT19),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 19)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[18],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT19),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[18],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT19),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[18],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT19),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[18],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT19),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[18],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT19),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[18],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT19),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[18],
        prompt   = STRING_TOKEN (STR_PCH_PCIE19_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[18] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[18],
          prompt      = STRING_TOKEN (STR_PCH_PCIE19_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[18] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[18],
            prompt      = STRING_TOKEN(STR_PCH_PCIE19_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[18],
            prompt      = STRING_TOKEN(STR_PCH_PCIE19_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[18],
          prompt      = STRING_TOKEN (STR_PCH_PCIE19_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[18] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[18],
            prompt      = STRING_TOKEN(STR_PCH_PCIE19_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[18],
            prompt      = STRING_TOKEN(STR_PCH_PCIE19_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[18],
          prompt      = STRING_TOKEN(STR_PCH_PCIE19_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[18],
        prompt   = STRING_TOKEN (STR_PCH_PCIE19_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[18],
        prompt   = STRING_TOKEN (STR_PCH_PCIE19_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[18] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[18],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT18),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP19_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP19_OPTIONS_FORM_ID



  form formid = AUTO_ID(PCH_PCIERP20_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP20_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[19],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP20_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[19] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[19],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY19),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[19],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT20),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[19],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT20),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[19],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT20),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[19],
        prompt      = STRING_TOKEN (STR_PCH_PCIE20_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[19],
        prompt      = STRING_TOKEN (STR_PCH_PCIE20_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[19],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT20),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

#if defined(DEFAULT_TBT_AIC_LOCATION) && (DEFAULT_TBT_AIC_LOCATION == 20)
#if defined(DEFAULT_TBT_ENABLE) && (DEFAULT_TBT_ENABLE == 1)
      oneof varid   = PCH_SETUP.PcieRootPortHPE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        default     = DEFAULT_TBT_PCIE_RP_HOTPLUG_CAP,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif
#else
      oneof varid   = PCH_SETUP.PcieRootPortHPE[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
#endif 

      oneof varid   = PCH_SETUP.PcieRootPortAER[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[19],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT20),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[19],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT20),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[19],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT20),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)    
      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
#endif                 
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[19],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT20),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[19],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT20),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 20,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[19],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT20),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 20,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
#if defined(Thunderbolt_SUPPORT) && (Thunderbolt_SUPPORT == 1)            
      endif;
#endif      

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[19],
        prompt   = STRING_TOKEN (STR_PCH_PCIE20_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[19] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[19],
          prompt      = STRING_TOKEN (STR_PCH_PCIE20_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[19] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[19],
            prompt      = STRING_TOKEN(STR_PCH_PCIE20_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[19],
            prompt      = STRING_TOKEN(STR_PCH_PCIE20_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[19],
          prompt      = STRING_TOKEN (STR_PCH_PCIE20_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[19] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[19],
            prompt      = STRING_TOKEN(STR_PCH_PCIE20_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[19],
            prompt      = STRING_TOKEN(STR_PCH_PCIE20_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[19],
          prompt      = STRING_TOKEN(STR_PCH_PCIE20_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[19],
        prompt   = STRING_TOKEN (STR_PCH_PCIE20_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[19],
        prompt   = STRING_TOKEN (STR_PCH_PCIE20_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[19] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[19],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT19),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP20_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif	
// AMI_OVERRIDE_END <<<        
      
    endif;
  endform; //End of PCH_PCIERP20_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_PCIERP21_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP21_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[20],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP21_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[20] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[20],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY20),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[20],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT21),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[20],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT21),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[20],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT21),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[20],
        prompt      = STRING_TOKEN (STR_PCH_PCIE21_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[20],
        prompt      = STRING_TOKEN (STR_PCH_PCIE21_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[20],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT21),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortHPE[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAER[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[20],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT21),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[20],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT21),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[20],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT21),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[20],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT21),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[20],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT21),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 21,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[20],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT21),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 21,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
      endif;

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[20],
        prompt   = STRING_TOKEN (STR_PCH_PCIE21_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[20] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[20],
          prompt      = STRING_TOKEN (STR_PCH_PCIE21_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[20] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[20],
            prompt      = STRING_TOKEN(STR_PCH_PCIE21_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[20],
            prompt      = STRING_TOKEN(STR_PCH_PCIE21_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[20],
          prompt      = STRING_TOKEN (STR_PCH_PCIE21_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[20] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[20],
            prompt      = STRING_TOKEN(STR_PCH_PCIE21_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[20],
            prompt      = STRING_TOKEN(STR_PCH_PCIE21_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[20],
          prompt      = STRING_TOKEN(STR_PCH_PCIE21_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[20],
        prompt   = STRING_TOKEN (STR_PCH_PCIE21_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[20],
        prompt   = STRING_TOKEN (STR_PCH_PCIE21_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[20] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[20],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT20),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;

// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP21_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif  
// AMI_OVERRIDE_END <<<      
      
    endif;
  endform; //End of PCH_PCIERP21_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_PCIERP22_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP22_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[21],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP22_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[21] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[21],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY21),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[21],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT22),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[21],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT22),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[21],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT22),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[21],
        prompt      = STRING_TOKEN (STR_PCH_PCIE22_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[21],
        prompt      = STRING_TOKEN (STR_PCH_PCIE22_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[21],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT22),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortHPE[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAER[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[21],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT22),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING |  RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[21],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT22),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[21],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT22),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[21],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT22),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[21],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT22),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 22,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[21],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT22),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 22,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
      endif;

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[21],
        prompt   = STRING_TOKEN (STR_PCH_PCIE22_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[21] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[21],
          prompt      = STRING_TOKEN (STR_PCH_PCIE22_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[21] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[21],
            prompt      = STRING_TOKEN(STR_PCH_PCIE22_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[21],
            prompt      = STRING_TOKEN(STR_PCH_PCIE22_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[21],
          prompt      = STRING_TOKEN (STR_PCH_PCIE22_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[21] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[21],
            prompt      = STRING_TOKEN(STR_PCH_PCIE22_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[21],
            prompt      = STRING_TOKEN(STR_PCH_PCIE22_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[21],
          prompt      = STRING_TOKEN(STR_PCH_PCIE22_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[21],
        prompt   = STRING_TOKEN (STR_PCH_PCIE22_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[21],
        prompt   = STRING_TOKEN (STR_PCH_PCIE22_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[21] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[21],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT21),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP22_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif  
// AMI_OVERRIDE_END <<<       
      
    endif;
  endform; //End of PCH_PCIERP22_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_PCIERP23_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP23_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[22],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP23_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[22] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[22],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY22),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[22],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT23),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[22],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT23),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[22],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT23),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[22],
        prompt      = STRING_TOKEN (STR_PCH_PCIE23_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[22],
        prompt      = STRING_TOKEN (STR_PCH_PCIE23_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[22],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT23),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortHPE[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAER[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[22],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT23),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[22],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT23),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[22],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT23),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[22],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT23),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[22],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT23),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 23,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[22],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT23),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 23,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
      endif;

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[22],
        prompt   = STRING_TOKEN (STR_PCH_PCIE23_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[22] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[22],
          prompt      = STRING_TOKEN (STR_PCH_PCIE23_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[22] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[22],
            prompt      = STRING_TOKEN(STR_PCH_PCIE23_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[22],
            prompt      = STRING_TOKEN(STR_PCH_PCIE23_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[22],
          prompt      = STRING_TOKEN (STR_PCH_PCIE23_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[22] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[22],
            prompt      = STRING_TOKEN(STR_PCH_PCIE23_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[22],
            prompt      = STRING_TOKEN(STR_PCH_PCIE23_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[22],
          prompt      = STRING_TOKEN(STR_PCH_PCIE23_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[22],
        prompt   = STRING_TOKEN (STR_PCH_PCIE23_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[22],
        prompt   = STRING_TOKEN (STR_PCH_PCIE23_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[22] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[22],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT22),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP23_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif  
// AMI_OVERRIDE_END <<<       
      
    endif;
  endform; //End of PCH_PCIERP23_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_PCIERP24_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_PCIERP24_OPTIONS_FORM_TITLE);

    oneof varid   = PCH_SETUP.PcieRootPortEn[23],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP24_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PcieRootPortEn[23] == 0x0;
      oneof varid = PCH_SETUP.PcieTopology[23],
       prompt = STRING_TOKEN(STR_PCIE_TOPOLOGY23),
       help = STRING_TOKEN(STR_PCIE_TOPOLOGY_HELP),
       option text = STRING_TOKEN(STR_PCIE_UNKNOWN_TOPOLOGY_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X1_STRING), value = 1, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_X4_STRING), value = 2, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_SATAE_STRING), value = 3, flags = RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCIE_M2_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAspm[23],
        prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT24),
        help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 4, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-BringUp] Bring Up Porting / PCIe ASPM Disabled

      oneof varid   = PCH_SETUP.PcieRootPortL1SubStates[23],
        prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT24),
        help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortEqPh3Method[23],
        prompt      = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_PROMPT24),
        help        = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HELP),
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_HW),           value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_STATIC_COEFF), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCIE_ROOTPORT_EQPH3_SOFT),         value = 2, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      numeric varid = PCH_SETUP.PcieRootPortUptp[23],
        prompt      = STRING_TOKEN (STR_PCH_PCIE24_UPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_UPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 5,
      endnumeric;

      numeric varid = PCH_SETUP.PcieRootPortDptp[23],
        prompt      = STRING_TOKEN (STR_PCH_PCIE24_DPTP_PROMPT),
        help        = STRING_TOKEN (STR_PCH_PCIE_DPTP_HELP),
        minimum     = 0,
        maximum     = 10,
        step        = 1,
        default     = 7,
      endnumeric;

      oneof varid   = PCH_SETUP.PcieRootPortACS[23],
        prompt      = STRING_TOKEN(STR_PCIE_ACS_PROMPT24),
        help        = STRING_TOKEN(STR_PCIE_ACS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortURE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortFEE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortNFE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCEE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortCTD[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_CTD_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_CTD_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSFE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSNE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSCE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortPMCE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortHPE[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_HPE_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_HPE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortAER[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_AER_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_AER_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortSpeed[23],
        prompt   = STRING_TOKEN (STR_PCIE_SPEED_PROMPT24),
        help     = STRING_TOKEN (STR_PCIE_SPEED_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     ? 0x0:0x2), defaultstore = MyStandardDefault,
//       option text = STRING_TOKEN (STR_AUTO), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_GEN3), value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = PCH_SETUP.PcieRootPortTHS[23],
        prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT24),
        help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      numeric varid = PCH_SETUP.PcieDetectTimeoutMs[23],
        prompt      = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_PROMPT24),
        help        = STRING_TOKEN (STR_PCH_PCIE_DETECT_TIMEOUT_HELP),
        minimum     = 0,
        maximum     = 65535,
        step        = 1,
        default     = 0,
      endnumeric;

      suppressif ideqval SETUP_DATA.TbtSupport == 1 AND
                 ideqval SETUP_DATA.TbtSelector == 1;
        numeric varid = PCH_SETUP.PcieExtraBusRsvd[23],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT24),
          help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
          minimum     = 0,
          maximum     = 7,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 0,    // default no extra bus reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieMemRsvd[23],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT24),
          help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
          minimum     = 1,
          maximum     = 24,
          step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 10,   // Default 10MB Memory Reserved
        endnumeric;

        numeric varid = PCH_SETUP.PcieIoRsvd[23],
          prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT24),
          help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
          minimum     = 4,
          maximum     = 24,
          step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
          default     = 4,    // Default 4K IO Reserved
        endnumeric;
      endif;

      SEPARATOR

      subtitle text = STRING_TOKEN(STR_PCH_PCIE_LTR_CONFIG);
      oneof varid   = PCH_SETUP.PchPcieLtrEnable[23],
        prompt   = STRING_TOKEN (STR_PCH_PCIE24_LTR_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTR_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchPcieLtrEnable[23] == 0;
        oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMode[23],
          prompt      = STRING_TOKEN (STR_PCH_PCIE24_SL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_SL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieSnoopLatencyOverrideMode[23] == 1;
          numeric varid = PCH_SETUP.PchPcieSnoopLatencyOverrideValue[23],
            prompt      = STRING_TOKEN(STR_PCH_PCIE24_SL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieSnoopLatencyOverrideMultiplier[23],
            prompt      = STRING_TOKEN(STR_PCH_PCIE24_SL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_SL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[23],
          prompt      = STRING_TOKEN (STR_PCH_PCIE24_NSL_OVRD_PROMPT),
          help        = STRING_TOKEN (STR_PCH_PCIE_NSL_OVRD_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MANUAL_STRING),   value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval PCH_SETUP.PchPcieNonSnoopLatencyOverrideMode[23] == 1;
          numeric varid = PCH_SETUP.PchPcieNonSnoopLatencyOverrideValue[23],
            prompt      = STRING_TOKEN(STR_PCH_PCIE24_NSL_VAL_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_VAL_HELP),
            flags       = RESET_REQUIRED,
            minimum     = 0,
            maximum     = 1023,
            step        = 1,
            default     = 60,
          endnumeric;

          oneof varid   = PCH_SETUP.PchPcieNonSnoopLatencyOverrideMultiplier[23],
            prompt      = STRING_TOKEN(STR_PCH_PCIE24_NSL_SCALE_PROMPT),
            help        = STRING_TOKEN(STR_PCH_PCIE_NSL_SCALE_HELP),
            option text = STRING_TOKEN(STR_LTR_SCALE_0), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_1), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_3), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_4), value = 4, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_LTR_SCALE_5), value = 5, flags = RESET_REQUIRED;
          endoneof;
        endif;

        oneof varid  = PCH_SETUP.PchPcieForceLtrOverride[23],
          prompt      = STRING_TOKEN(STR_PCH_PCIE24_LTR_OVRD_FORCE_PROMPT),
          help        = STRING_TOKEN(STR_PCH_PCIE_LTR_OVRD_FORCE_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      SEPARATOR

      oneof varid   = PCH_SETUP.PchPcieLtrConfigLock[23],
        prompt   = STRING_TOKEN (STR_PCH_PCIE24_LTRLOCK_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_LTRLOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      SEPARATOR
      subtitle text = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_CONFIG);

      oneof varid   = PCH_SETUP.PchPcieClkReqOverride[23],
        prompt   = STRING_TOKEN (STR_PCH_PCIE24_CLKREQ_OVERRIDE_PROMPT),
        help     = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_OVERRIDE_HELP),
        option text = STRING_TOKEN(STR_CLKREQ_DEFAULT),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_DISABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CLKREQ_CUSTOM),  value = 2, flags = RESET_REQUIRED;
      endoneof;
      suppressif NOT ideqval PCH_SETUP.PchPcieClkReqOverride[23] == 2;
        numeric varid = PCH_SETUP.PchPcieClkReqNumber[23],
          prompt = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_PROMPT23),
          help = STRING_TOKEN (STR_PCH_PCIE_CLKREQ_NUMBER_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0, maximum = 15, default = 0,
        endnumeric;
      endif;
      
// AMI_OVERRIDE_START >>>
#if defined(SB_SETUP_SUPPORT) && (SB_SETUP_SUPPORT == 1)
      SEPARATOR
      goto PCIERP24_OPTIONS_FORM_ID, 
        prompt = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_EXTRA_OPTIONS_FORM_HELP);
#endif  
// AMI_OVERRIDE_END <<<       
      
    endif;
  endform; //End of PCH_PCIERP24_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_HDAUDIO_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_HDAUDIO_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_HDAUDIO_OPTIONS_FORM_HELP))
    SEPARATOR

// AMI_OVERRIDE_START >>>
#ifndef SIMICS_FLAG
    oneof varid  = PCH_SETUP.PchHdAudio,
      prompt   = STRING_TOKEN(STR_PCH_HDA_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTO_STRING), value = 2, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
#else
    oneof varid  = PCH_SETUP.PchHdAudio,
      prompt   = STRING_TOKEN(STR_PCH_HDA_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTO_STRING), value = 2, flags = RESET_REQUIRED;
    endoneof;
#endif      
// AMI_OVERRIDE_END <<<

    suppressif ideqval PCH_SETUP.PchHdAudio == 0x0;
      oneof varid  = PCH_SETUP.PchHdAudioDsp,
        prompt   = STRING_TOKEN(STR_PCH_HDA_ADSP_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_ADSP_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
//ray_override / [XI-Tuning] Arrange Setup Default Setting / STR_ENABLED -> STR_DISABLED

      suppressif ideqval PCH_SETUP.PchHdAudioDsp == 0x0;
        oneof varid  = PCH_SETUP.PchHdAudioDspUaaCompliance,
          prompt   = STRING_TOKEN(STR_PCH_HDA_ADSP_UAA_COMP_PROMPT),
          help     = STRING_TOKEN(STR_PCH_HDA_ADSP_UAA_COMP_HELP),
          option text = STRING_TOKEN(STR_PCH_HDA_NON_UAA), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_HDA_UAA), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif; // PCH_SETUP.PchHdAudioDsp == 0x0;

      oneof varid  = PCH_SETUP.PchHdAudioCodecSelect,
        prompt   = STRING_TOKEN(STR_PCH_HDA_CODEC_SELECT_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_CODEC_SELECT_HELP),
        option text = STRING_TOKEN(STR_PCH_HDA_CODEC_PLATFORM_ONBOARD), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_CODEC_EXTERNAL_KIT), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = PCH_SETUP.PchHdaIDisplayCodecDisconnect,
        prompt   = STRING_TOKEN(STR_PCH_HDA_IDISP_CODEC_DIS_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_IDISP_CODEC_DIS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = PCH_SETUP.PchHdAudioPme,
        prompt   = STRING_TOKEN(STR_PCH_HDA_PME_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PME_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      goto PCH_HDAUDIO_ADVANCED_OPTIONS_FORM_ID,
        prompt = STRING_TOKEN(STR_HDAUDIO_ADVANCED_OPTIONS_FORM_TITLE),
        help = STRING_TOKEN(STR_HDAUDIO_ADVANCED_OPTIONS_FORM_HELP);

      suppressif ideqval PCH_SETUP.PchHdAudioDsp == 0x0;
        goto PCH_HDAUDIO_FEATURES_FORM_ID,
          prompt = STRING_TOKEN(STR_HDAUDIO_FEATURES_FORM_TITLE),
          help = STRING_TOKEN(STR_HDAUDIO_FEATURES_FORM_HELP);
      endif; //  PCH_SETUP.PchHdAudioDsp == 0x0;
    endif; // PCH_SETUP.PchHdAudio == 0x0;
  endform; //End of PCH_HDAUDIO_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_HDAUDIO_ADVANCED_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_HDAUDIO_ADVANCED_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_HDAUDIO_ADVANCED_OPTIONS_FORM_HELP))
    SEPARATOR

    text
       help   = STRING_TOKEN(STR_PCH_HDA_IO_CONTROL_HELP),
       text   = STRING_TOKEN(STR_PCH_HDA_IO_CONTROL_TITLE),
       flags  = 0,
       key    = 0;

    oneof varid  = PCH_SETUP.PchHdAudioIoBufferOwnership,
      prompt   = STRING_TOKEN(STR_PCH_HDA_IO_OWNERSHIP_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_IO_OWNERSHIP_HELP),
      option text = STRING_TOKEN(STR_PCH_HDA_IO_OWNERSHIP_HDALINK), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_HDA_IO_OWNERSHIP_HDALINK_I2S), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_HDA_IO_OWNERSHIP_I2S), value = 3, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PchHdAudioIoBufferOwnership == 0;
      oneof varid  = PCH_SETUP.PchHdAudioI2sCodecSelect,
        prompt   = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_SELECT_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_SELECT_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_5), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_6), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_I2S_CODEC_7), value = 7, flags = RESET_REQUIRED;
      endoneof;
    endif; //  PCH_SETUP.PchHdAudioIoBufferOwnership == 0;

    oneof varid  = PCH_SETUP.PchHdAudioIoBufferVoltage,
      prompt   = STRING_TOKEN(STR_PCH_HDA_IO_VOLTAGE_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_IO_VOLTAGE_HELP),
      option text = STRING_TOKEN(STR_PCH_HDA_IO_VOLTAGE_33V), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_HDA_IO_VOLTAGE_18V), value = 1, flags = RESET_REQUIRED;
    endoneof;

    text
       help   = STRING_TOKEN(STR_PCH_HDA_LINK_CONTROL_TITLE),
       text   = STRING_TOKEN(STR_PCH_HDA_LINK_CONTROL_TITLE),
       flags  = 0,
       key    = 0;

    oneof varid        = PCH_SETUP.PchHdaHdAudioLinkFreq,
           prompt      = STRING_TOKEN(STR_PCH_HDA_HDAUDIO_LINK_FREQ),
           help        = STRING_TOKEN(STR_PCH_HDA_HDAUDIO_LINK_FREQ_HELP),
// AMI_OVERRIDE_START
//           default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                      ? 0x2:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
           option text = STRING_TOKEN(STR_6MHZ),  value = 0, flags = RESET_REQUIRED;
           option text = STRING_TOKEN(STR_12MHZ), value = 1, flags = RESET_REQUIRED;
           option text = STRING_TOKEN(STR_24MHZ), value = 2, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    oneof varid        = PCH_SETUP.PchHdaIDisplayLinkFreq,
           prompt      = STRING_TOKEN(STR_PCH_HDA_IDISP_LINK_FREQ),
           help        = STRING_TOKEN(STR_PCH_HDA_IDISP_LINK_FREQ_HELP),
           option text = STRING_TOKEN(STR_48MHZ), value = 3, flags = RESET_REQUIRED;
           option text = STRING_TOKEN(STR_96MHZ), value = 4, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    suppressif ideqval PCH_SETUP.PchHdaIDisplayLinkFreq == 0x4;
      oneof varid  = PCH_SETUP.PchHdaIDisplayLinkTmode,
        prompt   = STRING_TOKEN(STR_PCH_HDA_IDISP_LINK_TMODE),
        help     = STRING_TOKEN(STR_PCH_HDA_IDISP_LINK_TMODE_HELP),
        option text = STRING_TOKEN(STR_PCH_HDA_IDISP_2T_MODE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_HDA_IDISP_1T_MODE), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif; //  PCH_SETUP.PchHdaIDisplayLinkFreq == 0x4;

  endform; //End of STR_HDAUDIO_ADVANCED_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_HDAUDIO_FEATURES_FORM_ID),
    title     = STRING_TOKEN(STR_HDAUDIO_FEATURES_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_HDAUDIO_FEATURES_FORM_HELP))
    SEPARATOR

    grayoutif NOT ideqval PCH_SETUP.PchHdAudioDspUaaCompliance == 0x0;
      // NHLT Endpoints selection
      text
         help   = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_TITLE),
         text   = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_TITLE),
         flags  = 0,
         key    = 0;

      oneof varid     = PCH_SETUP.PchHdAudioNhltEndpointDmic,
             prompt      = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_DMIC),
             help        = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_DMIC_HELP),
// AMI_OVERRIDE_START
             option text = STRING_TOKEN(STR_PCH_HDA_DMIC_4CH), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//             default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId ==  BoardIdSkylakeDtRvp8Crb BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb
//                                  ? cond(ideqvallist SETUP_VOLATILE_DATA.PlatId ==  BoardIdSkylakeSds 
//                                         ? 0x2:0x1):0x0), defaultstore = MyStandardDefault,
//             option text = STRING_TOKEN(STR_PCH_HDA_DMIC_4CH), value = 2, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
             option text = STRING_TOKEN(STR_PCH_HDA_DMIC_2CH), value = 1, flags = RESET_REQUIRED;
             option text = STRING_TOKEN(STR_PCH_HDA_DMIC_1CH), value = 3, flags = RESET_REQUIRED;
             option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof varid     = PCH_SETUP.PchHdAudioNhltEndpointBluetooth,
             prompt      = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_BT),
             help        = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_BT_HELP),
             option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
             option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid     = PCH_SETUP.PchHdAudioNhltEndpointI2s,
             prompt      = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_I2S),
             help        = STRING_TOKEN(STR_PCH_HDA_NHLT_ENDPOINT_I2S_HELP),
             option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        suppressif ideqval PCH_SETUP.PchHdAudioI2sCodecSelect == 0; // Enable I2S mode and select codec
             option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endif
      endoneof;
    endif; // UAA compliance check (PchHdAudioDspUaaCompliance)

    SEPARATOR
    // DSP Feature support selection
    text
       help   = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
       text   = STRING_TOKEN(STR_PCH_HDA_FEATURE_TITLE),
       flags  = 0,
       key    = 0;

      // Wake on Voice (WoV) support
      checkbox varid  = PCH_SETUP.PchHdAudioFeature[0],
        prompt   = STRING_TOKEN(STR_PCH_HDA_FEATURE_0_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
        // Flags behavior for checkbox is overloaded so that it equals
        // a DEFAULT value.  CHECKBOX_DEFAULT = ON, 0 = off
        flags    = RESET_REQUIRED,
// AMI_OVERRIDE_START
        default  = FALSE,
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? FALSE:TRUE), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
      endcheckbox;

      // BT Sideband support
      checkbox varid  = PCH_SETUP.PchHdAudioFeature[1],
        prompt   = STRING_TOKEN(STR_PCH_HDA_FEATURE_1_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      grayoutif ideqval PCH_SETUP.PchHdAudioFeature[1] == 0x0;
        // BT Intel HFP SCO
        checkbox varid  = PCH_SETUP.PchHdAudioFeature[5],
          prompt   = STRING_TOKEN(STR_PCH_HDA_FEATURE_5_PROMPT),
          help     = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
          flags    = 0 | RESET_REQUIRED,
          key      = 0,
        endcheckbox;

        // BT Intel A2DP
        checkbox varid  = PCH_SETUP.PchHdAudioFeature[6],
          prompt   = STRING_TOKEN(STR_PCH_HDA_FEATURE_6_PROMPT),
          help     = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
          flags    = 0 | RESET_REQUIRED,
          key      = 0,
        endcheckbox;
      endif; // BT Sideband Support

      // Codec based Voice Activity Detection (VAD) support
      checkbox varid  = PCH_SETUP.PchHdAudioFeature[2],
        prompt   = STRING_TOKEN(STR_PCH_HDA_FEATURE_2_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      grayoutif ideqval PCH_SETUP.PchHdAudioFeature[8] == 0x1;
        // DSP-based speech pre-processing disabled
        // Cannot be disabled (set) if selected WoV mode is 'Windows 10 Hardware Voice Activation for Cortana' (HdAudioFeature[BIT8] = 1)
        checkbox varid  = PCH_SETUP.PchHdAudioFeature[7],
          prompt   = STRING_TOKEN(STR_PCH_HDA_FEATURE_7_PROMPT),
          help     = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
          flags    = 0 | RESET_REQUIRED,
          key      = 0,
// AMI_OVERRIDE_START
        default  = FALSE,
//          default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                       ? FALSE:TRUE), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
        endcheckbox;
      endif; // WoV Mode check

      // WoV mode: support for Windows 10 Hardware Voice Activation for Cortana or Intel WoV
      oneof varid  = PCH_SETUP.PchHdAudioFeature[8],
        prompt      = STRING_TOKEN(STR_PCH_HDA_FEATURE_8_PROMPT),
        help        = STRING_TOKEN(STR_PCH_HDA_FEATURE_HELP),
        option text = STRING_TOKEN(STR_INTEL_WAKE_ON_VOICE), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_WIN_VOICE_ACTIVATION), value = 1, flags = RESET_REQUIRED;
      endoneof;

    SEPARATOR
    // DSP Pre/Post Processing module support selection
    text
       help   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
       text   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_TITLE),
       flags  = 0,
       key    = 0;

      // Post Processing Module 0 - Waves Post-process
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[0],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_0_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // Post Processing Module 1 - DTS
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[1],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_1_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // Pre Processing Module 2 - IntelSst Speech
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[2],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_2_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = RESET_REQUIRED,
// AMI_OVERRIDE_START
        default  = FALSE,
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? FALSE:TRUE), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
      endcheckbox;

      // Post Processing Module 3 - Dolby
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[3],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_3_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // Post Processing Module 4 - Waves Pre-process
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[4],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_4_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // Post Processing Module 5 - Audyssey
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[5],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_5_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // Post Processing Module 5 - Maxim Smart AMP
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[6],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_6_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // Post Processing Module 7 - ForteMedia SAMSoft
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[7],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_7_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

    // Check WoV support status in DspFeatureMask
    grayoutif ideqval PCH_SETUP.PchHdAudioFeature[0] == 0x0;
      // Pre Processing Module 8 - WoV Intel
      checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[8],
        prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_8_PROMPT),
        help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
// AMI_OVERRIDE_START
        default  = FALSE,
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? FALSE:TRUE), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
      endcheckbox;
    endif; // WoV Support

    // Post Processing Module 9 - Sound Research IP
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[9],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_9_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 10 - Conexant Pre-Process
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[10],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_10_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 11 - Conexant Smart Amp
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[11],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_11_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 12 - Realtek Post-Process
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[12],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_12_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 13 - Realtek Smart Amp
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[13],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_13_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 14 - Icepower IP MFX sub module
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[14],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_14_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 15 - Icepower IP EFX sub module
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[15],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_15_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Post Processing Module 16 - Icepower IP SFX sub module
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[16],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_16_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;

    // Custom Pre/Post-Processing modules with GUID entered by user
    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[29],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_29_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;
    suppressif ideqval PCH_SETUP.PchHdAudioPostProcessingMod[29] == 0x0;
      string  varid   = PCH_SETUP.PchHdAudioPostProcessingModCustomGuid1,
              prompt  = STRING_TOKEN(STR_PCH_HDA_PP_CUSTOM_GUID_29_PROMPT),
              help    = STRING_TOKEN(STR_PCH_HDA_PP_CUSTOM_GUID_HELP),
              flags   = 0 | RESET_REQUIRED, //INTERACTIVE,
              key     = 0,
              minsize = 36, // GUID characters number in format 11111111-2222-3333-4444-1234567890ab (without ending null)
              maxsize = 36,
      endstring;
    endif; // Custom module 29 disabled

    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[30],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_30_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;
    suppressif ideqval PCH_SETUP.PchHdAudioPostProcessingMod[30] == 0x0;
      string  varid   = PCH_SETUP.PchHdAudioPostProcessingModCustomGuid2,
              prompt  = STRING_TOKEN(STR_PCH_HDA_PP_CUSTOM_GUID_30_PROMPT),
              help    = STRING_TOKEN(STR_PCH_HDA_PP_CUSTOM_GUID_HELP),
              flags   = 0 | RESET_REQUIRED, //INTERACTIVE,
              key     = 0,
              minsize = 36, // GUID characters number in format 11111111-2222-3333-4444-1234567890ab (without ending null)
              maxsize = 36,
      endstring;
    endif; // Custom module 30 disabled

    checkbox varid  = PCH_SETUP.PchHdAudioPostProcessingMod[31],
      prompt   = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_31_PROMPT),
      help     = STRING_TOKEN(STR_PCH_HDA_PP_MODULE_HELP),
      flags    = 0 | RESET_REQUIRED,
      key      = 0,
    endcheckbox;
    suppressif ideqval PCH_SETUP.PchHdAudioPostProcessingMod[31] == 0x0;
      string  varid   = PCH_SETUP.PchHdAudioPostProcessingModCustomGuid3,
              prompt  = STRING_TOKEN(STR_PCH_HDA_PP_CUSTOM_GUID_31_PROMPT),
              help    = STRING_TOKEN(STR_PCH_HDA_PP_CUSTOM_GUID_HELP),
              flags   = 0 | RESET_REQUIRED, //INTERACTIVE,
              key     = 0,
              minsize = 36, // GUID characters number in format 11111111-2222-3333-4444-1234567890ab (without ending null)
              maxsize = 36,
      endstring;
    endif; // Custom module 31 disabled
  endform; //End of PCH_HDAUDIO_FEATURES_FORM_ID

  form formid = AUTO_ID(SECURITY_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_SECURITY_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_SECURITY_OPTIONS_FORM_SUBTITLE))
    SEPARATOR

#if 0  // AMI_OVERRIDE_START   
    oneof varid  = PCH_SETUP.PchRtcLock,
      prompt   = STRING_TOKEN(STR_PCH_RTC_LOCK_PROMPT),
      help     = STRING_TOKEN(STR_PCH_RTC_LOCK_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
#else
    oneof varid  = PCH_SETUP.PchRtcLock,
      prompt   = STRING_TOKEN(STR_PCH_RTC_LOCK_PROMPT),
      help     = STRING_TOKEN(STR_PCH_RTC_LOCK_HELP),
      default     = RTC_LOCK_ENABLE,
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = MANUFACTURING | RESET_REQUIRED;
    endoneof;
#endif  // AMI_OVERRIDE_END   

    suppressif ideqvallist CPU_SETUP.BiosGuard == 1;
#if 0  // AMI_OVERRIDE_START         
      oneof varid  = PCH_SETUP.PchBiosLock,
        prompt   = STRING_TOKEN(STR_PCH_BLE_PROMPT),
        help     = STRING_TOKEN(STR_PCH_BLE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
#else
    oneof varid  = PCH_SETUP.PchBiosLock,
      prompt   = STRING_TOKEN(STR_PCH_BLE_PROMPT),
      help     = STRING_TOKEN(STR_PCH_BLE_HELP),
      default     = BIOS_LOCK_ENABLE,                     
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
#endif  // AMI_OVERRIDE_END
    endif;
  endform; //End of SECURITY_OPTIONS_FORM_ID

//
// SerialIo
//
form formid = AUTO_ID(STR_122_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_OPTIONS_FORM_SUBTITLE))

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
      oneof varid  = SETUP_DATA.TouchPanelMuxSelector,
        prompt   = STRING_TOKEN(STR_TOUCH_PANEL_PROMPT),
        help     = STRING_TOKEN(STR_TOUCH_PANEL_HELP),
        option text = STRING_TOKEN(STR_TOUCH_PANEL_SPI), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_TOUCH_PANEL_I2C), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = SETUP_DATA.BtUartMuxSelector,
        prompt   = STRING_TOKEN(STR_BT_UART_MUX_PROMPT),
        help     = STRING_TOKEN(STR_BT_UART_MUX_HELP),
        option text = STRING_TOKEN(STR_BT_UART_MUX_UART), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_BT_UART_MUX_BT),   value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    //
    // I2C1-3 would be undetectable by OS if I2C0 is disabled, because it's Function0 of their PCIE device
    //
    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C1] == 1 OR
              ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C2] == 1 OR
              ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C3] == 1;
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C0],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C0),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
// AMI_OVERRIDE_START  
//        default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb ? 0x1:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END  
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;
//ray_override / [XI-Tuning] Arrange Setup Default Setting

    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C0] == 0;
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C1],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C1),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
// AMI_OVERRIDE_START        
//        default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb BoardIdSkylakeSdlBrk ? 0x1:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END        
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;
//ray_override / [XI-Tuning] Arrange Setup Default Setting

    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C0] == 0;
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C2],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C2),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                      ? 0x0:0x1), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C0] == 0;
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C3],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C3),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    suppressif
               (ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3
                                                         BoardIdSkylakeA0Rvp3Ppv
                                                         BoardIdSkylakeULpddr3Rvp5
                                                         BoardIdSkylakeULpddr3Rvp5Ppv
                                                         BoardIdSkylakeLpdimmDoe
                                                         BoardIdSkylakeURvp7
                                                         BoardIdKabylakeRDdr4
                                                         BoardIdKabylakeRLpddr3
                                                         BoardIdKabylakeKcDdr3
                                                         BoardIdSkylakeURvp7Ppv
                                                         BoardIdSkylakeURvp15) OR
               NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx;
    oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C4],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C4_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART2] == 0;
      option text = STRING_TOKEN(STR_ENABLED_PCI_MODE), value = 1, flags = RESET_REQUIRED;
      endif
      option text = STRING_TOKEN(STR_ENABLED_ACPI_MODE), value = 2, flags = RESET_REQUIRED;
    endoneof;
    endif;
    suppressif NOT ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3
                                                             BoardIdSkylakeA0Rvp3Ppv
                                                             BoardIdSkylakeULpddr3Rvp5
                                                             BoardIdSkylakeULpddr3Rvp5Ppv
                                                             BoardIdSkylakeLpdimmDoe
                                                             BoardIdSkylakeURvp7
                                                             BoardIdKabylakeRDdr4
                                                             BoardIdKabylakeRLpddr3
                                                             BoardIdKabylakeKcDdr3
                                                             BoardIdSkylakeURvp7Ppv
                                                             BoardIdSkylakeURvp15;
      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C4),
        text   = STRING_TOKEN(STR_PCH_RESERVED_FOR_EXPANDER),
        flags = 0, key = 0;
    endif;

    suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx;
    oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C5],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C5),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART2] == 0;
        option text = STRING_TOKEN(STR_ENABLED_PCI_MODE), value = 1, flags = RESET_REQUIRED;
        endif
        option text = STRING_TOKEN(STR_ENABLED_ACPI_MODE), value = 2, flags = RESET_REQUIRED;
    endoneof;
    endif;

    grayoutif  ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0] == 0;
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_SPI0],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_SPI0),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;
    grayoutif  ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0] == 0;
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_SPI1],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_SPI1),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
// AMI_OVERRIDE_START
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds BoardIdSkylakeStarbrook
//                            ? 0x0:0x1), defaultstore = MyStandardDefault,
//        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART1] == 1 OR
              ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_SPI0] == 1 OR
              ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_SPI1] == 1 OR
              ( ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx AND
              ( ideqval PCH_SETUP.PchScsEmmcEnabled == 1 OR
              ideqval PCH_SETUP.PchScsSdCardEnabled == 1 ));
      oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART0),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
// AMI_OVERRIDE_START  
//        default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdZumbaBeachServerEv BoardIdZumbaBeachServerCrb BoardIdSkylakeSdlBrk ? 0x1:0x0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END  
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;
//ray_override / [XI-Tuning] Arrange Setup Default Setting

    grayoutif  ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0] == 0 OR
               ideqval SETUP_DATA.GnssConnection == 1;
    oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART1],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART1),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
    endif;

    suppressif ideqval PCH_SETUP.OsDebugPort == 3;
    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C4] == 1 OR
              ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C5] == 1;
// AMI_OVERRIDE_START >>>              
#ifndef MDEPKG_NDEBUG
    oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART2],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART2_PROMPT1),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DBG_ONLY), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
#else
    oneof varid  = PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART2],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART2_PROMPT2),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
#endif      
// AMI_OVERRIDE_END <<<    
    endif;
    endif;


    suppressif NOT ideqval PCH_SETUP.OsDebugPort == 3;
      text
        help   = STRING_TOKEN(STR_EMPTY_STRING),
        text   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART2),
        text   = STRING_TOKEN(STR_PCH_RESERVED_FOR_DBG),
        flags = 0, key = 0;
    endif;

    oneof varid  = PCH_SETUP.PchGpio,
      prompt   = STRING_TOKEN(STR_PCH_GPIO),
      help     = STRING_TOKEN(STR_PCH_GPIO_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    SEPARATOR

    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C0] == 0;
        goto STR_128_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_I2C0_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C1] == 0;
        goto STR_129_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_I2C1_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;

    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C2] == 0;
        goto STR_135_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_I2C2_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C3] == 0;
        goto STR_136_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_I2C3_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;

    suppressif
               ( ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3
                                                         BoardIdSkylakeA0Rvp3Ppv
                                                         BoardIdSkylakeULpddr3Rvp5
                                                         BoardIdSkylakeULpddr3Rvp5Ppv
                                                         BoardIdSkylakeLpdimmDoe
                                                         BoardIdSkylakeURvp7
                                                         BoardIdKabylakeRDdr4
                                                         BoardIdKabylakeRLpddr3
                                                         BoardIdKabylakeKcDdr3
                                                         BoardIdSkylakeURvp7Ppv
                                                         BoardIdSkylakeURvp15) OR
               ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C4] == 0;
        goto STR_137_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_I2C4_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C5] == 0;
        goto STR_138_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_I2C5_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;

    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_SPI0] == 0;
        goto STR_130_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_SPI0_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_SPI1] == 0;
        goto STR_131_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_SPI1_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0] == 0 OR
               ideqval PCH_SETUP.OsDebugPort == 1;
        goto STR_132_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_UART0_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART1] == 0 OR
               ideqval PCH_SETUP.OsDebugPort == 2;
        goto STR_133_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_UART1_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;
    suppressif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART2] == 0;
        goto STR_139_FORM_ID, // AMI_OVERRIDE
          prompt = STRING_TOKEN(STR_SERIAL_IO_UART2_FORM),
          help = STRING_TOKEN(STR_SERIAL_IO_CTRL_FORM_HELP);
    endif;

    suppressif ideqval PCH_SETUP.PchGpio == 0;
        goto STR_124_FORM_ID, // AMI_OVERRIDE
          prompt  = STRING_TOKEN(STR_GPIO_FORM_TITLE),
          help    = STRING_TOKEN(STR_GPIO_FORM_HELP);
    endif;

    SEPARATOR

    oneof varid  = SETUP_DATA.PchI2cWittDevice,
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_WITT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_WITT_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_I2C0), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_I2C1), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_I2C2), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_I2C3), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_I2C4), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_I2C5), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_SPI0), value = 7, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_WITT_ENABLED_SPI1), value = 8, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.PchI2cWittDevice == 0;
      oneof varid  = SETUP_DATA.PchI2cWittVersion,
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_WITT_VER),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_WITT_VER_HELP),
        option text = STRING_TOKEN(STR_WITT), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MITT), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;
    oneof varid  = SETUP_DATA.PchUartUtkDevice,
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_UTK),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_UTK_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED_UART0), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED_UART1), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED_UART2), value = 3, flags = RESET_REQUIRED;
    endoneof;
    checkbox varid  = PCH_SETUP.PchAdditionalSerialIoDevices,
      prompt      = STRING_TOKEN(STR_SERIAL_IO_TEST_DEVICES),
      help        = STRING_TOKEN(STR_SERIAL_IO_TEST_DEVICES_HELP),
      flags   = RESET_REQUIRED, key = 0,
    endcheckbox;

    goto STR_140_FORM_ID, // AMI_OVERRIDE
      prompt = STRING_TOKEN(STR_SERIAL_IO_TIMING_FORM),
      help = STRING_TOKEN(STR_SERIAL_IO_TIMING_FORM_HELP);

    oneof varid  = PCH_SETUP.PchUcsiUcmcDevice,
      prompt   = STRING_TOKEN(STR_PCH_I2C_UCSI_UCMC),
      help     = STRING_TOKEN(STR_PCH_STR_PCH_I2C_UCSI_UCMC_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
endform; //End of SerialIo Options Form ID

  form formid = AUTO_ID(STR_140_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_TIMING_FORM);

    checkbox varid  = SETUP_DATA.PchSerialIoUseTimingParameters,
      prompt      = STRING_TOKEN(STR_SERIAL_IO_TIMING),
      help        = STRING_TOKEN(STR_SERIAL_IO_TIMING_HELP),
      flags   = RESET_REQUIRED, key = 0,
    endcheckbox;
    suppressif ideqval SETUP_DATA.PchSerialIoUseTimingParameters == 0;
      numeric varid = SETUP_DATA.PchSerialIoTimingSSHI,
        prompt = STRING_TOKEN (STR_PCH_SIO_SSCN_HIGH), help = STRING_TOKEN (STR_PCH_SIO_SSCN_HIGH_HELP), minimum = 0, maximum = 65535, default = 528,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingSSLI,
        prompt = STRING_TOKEN (STR_PCH_SIO_SSCN_LOW), help = STRING_TOKEN (STR_PCH_SIO_SSCN_LOW_HELP), minimum = 0, maximum = 65535, default = 640,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingSSDI,
        prompt = STRING_TOKEN (STR_PCH_SIO_SSCN_HOLD), help = STRING_TOKEN (STR_PCH_SIO_SSCN_HOLD_HELP), minimum = 0, maximum = 65535, default = 30,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingFMHI,
        prompt = STRING_TOKEN (STR_PCH_SIO_FMCN_HIGH), help = STRING_TOKEN (STR_PCH_SIO_FSCN_HIGH_HELP), minimum = 0, maximum = 65535, default = 128,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingFMLI,
        prompt = STRING_TOKEN (STR_PCH_SIO_FMCN_LOW), help = STRING_TOKEN (STR_PCH_SIO_FSCN_LOW_HELP), minimum = 0, maximum = 65535, default = 160,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingFMDI,
        prompt = STRING_TOKEN (STR_PCH_SIO_FMCN_HOLD), help = STRING_TOKEN (STR_PCH_SIO_FSCN_HOLD_HELP), minimum = 0, maximum = 65535, default = 30,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingFPHI,
        prompt = STRING_TOKEN (STR_PCH_SIO_FPCN_HIGH), help = STRING_TOKEN (STR_PCH_SIO_FPCN_HIGH_HELP), minimum = 0, maximum = 65535, default = 48,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingFPLI,
        prompt = STRING_TOKEN (STR_PCH_SIO_FPCN_LOW), help = STRING_TOKEN (STR_PCH_SIO_FPCN_LOW_HELP), minimum = 0, maximum = 65535, default = 64,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingFPDI,
        prompt = STRING_TOKEN (STR_PCH_SIO_FPCN_HOLD), help = STRING_TOKEN (STR_PCH_SIO_FPCN_HOLD_HELP), minimum = 0, maximum = 65535, default = 30,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingM0CI,
        prompt = STRING_TOKEN (STR_PCH_SIO_M0D3_I2C), help = STRING_TOKEN (STR_PCH_SIO_M0D3_HELP), minimum = 1, maximum = 10000, default = 200,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingM1CI,
        prompt = STRING_TOKEN (STR_PCH_SIO_M1D3_I2C), help = STRING_TOKEN (STR_PCH_SIO_M1D3_HELP), minimum = 1, maximum = 10000, default = 2000,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingM0CS,
        prompt = STRING_TOKEN (STR_PCH_SIO_M0D3_SPI), help = STRING_TOKEN (STR_PCH_SIO_M0D3_HELP), minimum = 1, maximum = 10000, default = 200,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingM1CS,
        prompt = STRING_TOKEN (STR_PCH_SIO_M1D3_SPI), help = STRING_TOKEN (STR_PCH_SIO_M1D3_HELP), minimum = 1, maximum = 10000, default = 2000,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingM0CU,
        prompt = STRING_TOKEN (STR_PCH_SIO_M0D3_UART), help = STRING_TOKEN (STR_PCH_SIO_M0D3_HELP), minimum = 1, maximum = 10000, default = 200,
      endnumeric;
      numeric varid = SETUP_DATA.PchSerialIoTimingM1CU,
        prompt = STRING_TOKEN (STR_PCH_SIO_M1D3_UART), help = STRING_TOKEN (STR_PCH_SIO_M1D3_HELP), minimum = 1, maximum = 10000, default = 200,
      endnumeric;
    endif;
endform;



  form formid = AUTO_ID(STR_128_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_I2C0_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_I2C0_FORM_TITLE_SUBTITLE))

    oneof varid  = PCH_SETUP.PchI2cVoltageSelect[0],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C0_VOLTAGE_SEL_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_HELP),
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_33V), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_18V), value = 1, flags = RESET_REQUIRED;
    endoneof;

    SEPARATOR

    oneof varid  = SETUP_DATA.PchI2c0SensorDevice,
      prompt   = STRING_TOKEN(STR_PCH_I2C0_SENSOR_DEVICE),
      help     = STRING_TOKEN(STR_PCH_SENSOR_DEVICE_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                         ? 0x0:0x4), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_PCH_SYNAPTIC_PRECISION_TOUCH_PAD), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SYNAPTIC_FORCEPAD), value = 2, flags = RESET_REQUIRED;
      // ALPS Precision Touchpad (ClickPad)
      option text = STRING_TOKEN(STR_PCH_ALPS_PRECISION_TOUCHPAD), value = 6, flags = RESET_REQUIRED;
      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
      option text = STRING_TOKEN(STR_PCH_SAR_SX9306), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SAR_SX9310), value = 4, flags = RESET_REQUIRED;
      endif
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_CUSTOM_DEVICE), value = 5, flags = RESET_REQUIRED;
    endoneof;
    suppressif ideqval SETUP_DATA.PchI2c0SensorDevice == 0 OR
               ideqval SETUP_DATA.PchI2c0SensorDevice == 3 OR
               ideqval SETUP_DATA.PchI2c0SensorDevice == 4;
    oneof varid  = SETUP_DATA.PchI2c0SensorIrqMode,
      prompt   = STRING_TOKEN(STR_PCH_I2C0_SENSOR_IRQ_MODE),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_IRQ_MODE_HELP),
      option text = STRING_TOKEN(STR_GPIO_INT), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_APIC_INT), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
    endif;

    suppressif NOT ideqval SETUP_DATA.PchI2c0SensorDevice == 5;
      numeric varid = SETUP_DATA.PchI2c0TouchpadBusAddress,
        prompt      = STRING_TOKEN(STR_I2C0_CUSTOM_DEVICE_BUS_ADDRESS),
        help        = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0,
      endnumeric;

      numeric varid = SETUP_DATA.PchI2c0TouchpadHidAddress,
        prompt      = STRING_TOKEN(STR_I2C0_CUSTOM_DEVICE_HID_ADDRESS),
        help        = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0xFFFF,
        step     = 1,
        default  = 0,
      endnumeric;

      oneof varid  = SETUP_DATA.PchI2c0TouchpadSpeed,
        prompt   = STRING_TOKEN(STR_I2C0_CUSTOM_DEVICE_SPEED),
        help     = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_100K), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_400K), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_1M),   value = 2, flags = RESET_REQUIRED;
      endoneof;

    endif;

 endform;




  form formid = AUTO_ID(STR_129_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_I2C1_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_I2C1_FORM_SUBTITLE))

    oneof varid  = PCH_SETUP.PchI2cVoltageSelect[1],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C1_VOLTAGE_SEL_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_HELP),
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_33V), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_18V), value = 1, flags = RESET_REQUIRED;
    endoneof;

    SEPARATOR

    oneof varid  = SETUP_DATA.PchI2c1SensorDevice,
        prompt   = STRING_TOKEN(STR_PCH_I2C1_SENSOR_DEVICE),
        help     = STRING_TOKEN(STR_PCH_SENSOR_DEVICE_HELP),
        option text = STRING_TOKEN(STR_DISABLED),                          value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_ATMEL3432_PANEL),     value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_ATMEL2952_PANEL),     value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_ELAN2097_PANEL),      value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_NTRIG_SAMSUNG_PANEL), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_NTRIG_SHARP_PANEL),   value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_WACOM9015_PANEL),     value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_IO_CUSTOM_DEVICE),       value = 7, flags = RESET_REQUIRED;
      endoneof;

    suppressif ideqval SETUP_DATA.PchI2c1SensorDevice == 0;
      oneof varid  = SETUP_DATA.PchI2c1SensorIrqMode,
        prompt   = STRING_TOKEN(STR_PCH_I2C1_SENSOR_IRQ_MODE),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_IRQ_MODE_HELP),
        option text = STRING_TOKEN(STR_GPIO_INT), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_APIC_INT), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    // Specific to WACOM 9015: Supports Fast mode(400Khz), Fast mode+(1MHz)

    suppressif NOT ideqval SETUP_DATA.PchI2c1SensorDevice == 6;
      oneof varid  = SETUP_DATA.PchI2c1WacompanelSpeed,
        prompt   = STRING_TOKEN(STR_I2C1_WACOM_PANEL_SPEED),
        help     = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_400K), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_1M),   value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif NOT ideqval SETUP_DATA.PchI2c1SensorDevice == 7;
      numeric varid = SETUP_DATA.PchI2c1TouchpanelBusAddress,
        prompt      = STRING_TOKEN(STR_I2C1_CUSTOM_DEVICE_BUS_ADDRESS),
        help        = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0,
      endnumeric;

      numeric varid = SETUP_DATA.PchI2c1TouchpanelHidAddress,
        prompt      = STRING_TOKEN(STR_I2C1_CUSTOM_DEVICE_HID_ADDRESS),
        help        = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0xFFFF,
        step     = 1,
        default  = 0,
      endnumeric;

      oneof varid  = SETUP_DATA.PchI2c1TouchpanelSpeed,
        prompt   = STRING_TOKEN(STR_I2C1_CUSTOM_DEVICE_SPEED),
        help     = STRING_TOKEN(STR_CUSTOM_DEVICE_PARAMETERS_HELP),
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_100K), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_400K), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CUSTOM_DEVICE_SPEED_1M),   value = 2, flags = RESET_REQUIRED;
      endoneof;

    endif;

 endform;


  form formid = AUTO_ID(STR_135_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_I2C2_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_I2C2_FORM_SUBTITLE))

     oneof varid  = PCH_SETUP.PchI2cVoltageSelect[2],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C2_VOLTAGE_SEL_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_HELP),
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_33V), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_18V), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

endform;


  form formid = AUTO_ID(STR_136_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_I2C3_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_I2C3_FORM_SUBTITLE))

    oneof varid  = PCH_SETUP.PchI2cVoltageSelect[3],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C3_VOLTAGE_SEL_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_HELP),
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_33V), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_18V), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

 endform;


  form formid = AUTO_ID(STR_137_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_I2C4_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_I2C4_FORM_SUBTITLE))

    oneof varid  = PCH_SETUP.PchI2cVoltageSelect[4],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C4_VOLTAGE_SEL_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_HELP),
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_33V), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_18V), value = 1, flags = RESET_REQUIRED;
    endoneof;

 endform;


  form formid = AUTO_ID(STR_138_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_I2C5_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_I2C5_FORM_SUBTITLE))

    oneof varid  = PCH_SETUP.PchI2cVoltageSelect[5],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_I2C5_VOLTAGE_SEL_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_HELP),
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_33V), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SERIAL_IO_VOLTAGE_SELECT_18V), value = 1, flags = RESET_REQUIRED;
    endoneof;

 endform;


  form formid = AUTO_ID(STR_130_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_SPI0_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_SPI0_FORM_SUBTITLE))

      oneof varid  = PCH_SETUP.PchSpiCsPolaritySelect[0],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_SPI_CS_POLARITY_PROMPT),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_SPI_CS_POLARITY_HELP),
        option text = STRING_TOKEN(STR_PCH_SERIAL_SPI_CS_ACTIVE_LOW), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PCH_SERIAL_SPI_CS_ACTIVE_HIGH), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

 endform;

  form formid = AUTO_ID(STR_131_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_SPI1_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_SPI1_FORM_SUBTITLE))

      SEPARATOR

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
        oneof varid  = SETUP_DATA.PchFpsEnable,
          prompt   = STRING_TOKEN(STR_FPS_ENABLE),
          help     = STRING_TOKEN(STR_FPS_ENABLE_HELP),
// AMI_OVERRIDE_START
          option text = STRING_TOKEN(STR_AUTO),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//          default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv BoardIdSkylakeULpddr3Rvp5Ppv BoardIdSkylakeURvp7Ppv BoardIdSkylakeAioRvp10CrbPpv BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                      ? 0x2:0x0), defaultstore = MyStandardDefault,
//          option text = STRING_TOKEN(STR_AUTO),     value = 2, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        endoneof;
      endif;

      grayoutif
                ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds AND
                NOT ideqval SETUP_DATA.PchFpsEnable == 1;
        oneof varid  = SETUP_DATA.PchSpi1SensorDevice,
          prompt   = STRING_TOKEN(STR_SERIALIO_SPI1_FPS),
          help     = STRING_TOKEN(STR_SERIALIO_SPI1_FPS_HELP),
// AMI_OVERRIDE_START
          option text = STRING_TOKEN(STR_DISABLED),                  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//          default value=cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//          BoardIdKabylakeDdr4Rvp17  //KblGContent
//                             ? 0x0:0x6), defaultstore = MyStandardDefault,
//          option text = STRING_TOKEN(STR_DISABLED),                  value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
          option text = STRING_TOKEN(STR_SERIALIO_SPI_FPS_FPC1011),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIALIO_SPI_FPS_FPC1020),  value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIALIO_SPI_FPS_VFSI6101), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIALIO_SPI_FPS_VFSI7500), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIALIO_SPI_FPS_EGIS0300), value = 5, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIALIO_SPI_FPS_FPC1021),  value = 6, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.PchSpi1SensorDevice == 0;
      oneof varid  = SETUP_DATA.PchSpi1SensorIrqMode,
        prompt   = STRING_TOKEN(STR_PCH_SPI1_SENSOR_IRQ_MODE),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_IRQ_MODE_HELP),
//
// KblGBegin
//
        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdKabylakeDdr4Rvp17
                             ? 0x1:0x0), defaultstore = MyStandardDefault,
//
// KblGEnd
//
        option text = STRING_TOKEN(STR_GPIO_INT), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_APIC_INT), value = 1, flags = MANUFACTURING | RESET_REQUIRED;
      endoneof;
      endif;

 endform;




  form formid = AUTO_ID(STR_132_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_UART0_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_UART0_FORM_SUBTITLE))

      oneof varid  = SETUP_DATA.PchUart0SensorDevice,
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_BLUETOOTH_DEVICE),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_SENSOR_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_BT_INT33E1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_BT_BCM2E40), value = 2, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.PchUart0SensorDevice == 0;
      oneof varid  = SETUP_DATA.PchUart0SensorIrqMode,
        prompt   = STRING_TOKEN(STR_PCH_UART0_SENSOR_IRQ_MODE),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_DEVICE_IRQ_MODE_HELP),
        option text = STRING_TOKEN(STR_GPIO_INT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_APIC_INT), value = 1, flags = RESET_REQUIRED;
      endoneof;
      endif;

      oneof varid  = SETUP_DATA.BtWirelessChargingMode,
        prompt   = STRING_TOKEN(STR_BT_WIRELESS_CHARGING_MODE),
        help     = STRING_TOKEN(STR_BT_WIRELESS_CHARGING_MODE_HELP),
        option text = STRING_TOKEN(STR_WC_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_WC_ENABLED), value = 1, flags  = RESET_REQUIRED;
      endoneof;

      oneof varid  = PCH_SETUP.PchUartHwFlowCtrl[0],
        prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_HW_FLOW_CTRL0_PROMPT),
        help     = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_HW_FLOW_CTRL_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

 endform;




  form formid = AUTO_ID(STR_133_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_UART1_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_UART1_FORM_SUBTITLE))

    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_GNSS_MOVED),
      text   = STRING_TOKEN(STR_EMPTY_STRING),
      flags = 0, key = 0;

    oneof varid  = PCH_SETUP.PchUartHwFlowCtrl[1],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_HW_FLOW_CTRL1_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_HW_FLOW_CTRL_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

   endform;




  form formid = AUTO_ID(STR_139_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_SERIAL_IO_UART2_FORM_TITLE);
    SUBTITLE(STRING_TOKEN(STR_SERIAL_IO_UART2_FORM_SUBTITLE))

    oneof varid  = PCH_SETUP.PchUartHwFlowCtrl[2],
      prompt   = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_HW_FLOW_CTRL2_PROMPT),
      help     = STRING_TOKEN(STR_PCH_SERIAL_IO_UART_HW_FLOW_CTRL_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

 endform;


//endform; //End of SerialIo Options Form ID
//
// GPIO
//
form formid = AUTO_ID(STR_124_FORM_ID), // AMI_OVERRIDE
    title     = STRING_TOKEN(STR_GPIO_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_GPIO_OPTIONS_FORM_TITLE))

     oneof varid  = PCH_SETUP.PchGpioIrqRoute,
       prompt   = STRING_TOKEN(STR_PCH_GPIO_IRQ_ROUTE),
       help     = STRING_TOKEN(STR_PCH_GPIO_IRQ_ROUTE_HELP),
       option text = STRING_TOKEN(STR_PCH_GPIO_ROUTE_IRQ14), value = 14, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
       option text = STRING_TOKEN(STR_PCH_GPIO_ROUTE_IRQ15), value = 15, flags = RESET_REQUIRED;
     endoneof;

  endform; //End of GPIO Options Form ID



  form formid = AUTO_ID(SKYCAM_CIO2_OPTIONS_FORM_ID),
    title = STRING_TOKEN(STR_SKYCAM_CIO2_OPTIONS_FORM_TITLE);

    oneof varid  = PCH_SETUP.PchSkyCamCio2Enable,
      prompt   = STRING_TOKEN(STR_SKYCAM_CIO2_DEVICE_ENABLE),
      help     = STRING_TOKEN(STR_SKYCAM_CIO2_DEVICE_ENABLE_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid     = SETUP_DATA.SkyCam_ControlLogic0,
      prompt      = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0),
      help        = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                 ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0 == 0;
      goto STR_145_FORM_ID, // AMI_OVERRIDE // go to ControlLogic0 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS1),
        help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_HELP1),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_ControlLogic1,
      prompt      = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1),
      help        = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1 == 0;
      goto STR_146_FORM_ID, // AMI_OVERRIDE // go to ControlLogic1 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS2),
        help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_HELP2),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_ControlLogic2,
      prompt      = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2),
      help        = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2 == 0;
      goto STR_147_FORM_ID, // AMI_OVERRIDE // go to ControlLogic2 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS3),
        help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_HELP3),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_ControlLogic3,
      prompt      = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3),
      help        = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3 == 0;
      goto STR_148_FORM_ID, // AMI_OVERRIDE // go to ControlLogic3 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS4),
        help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_HELP4),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_Link0,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0),
      help        = STRING_TOKEN(STR_SKYCAM_LINK0_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                 ? 0x0:0x1), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_Link0 == 0;
      goto STR_141_FORM_ID, // AMI_OVERRIDE // go to Link0 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        help     = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_Link1,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1),
      help        = STRING_TOKEN(STR_SKYCAM_LINK1_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_Link1 == 0;
      goto STR_142_FORM_ID, // AMI_OVERRIDE  // go to Link1 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        help     = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_Link2,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2),
      help        = STRING_TOKEN(STR_SKYCAM_LINK2_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_Link2 == 0;
      goto STR_143_FORM_ID, // AMI_OVERRIDE  // go to Link2 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        help     = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_Link3,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3),
      help        = STRING_TOKEN(STR_SKYCAM_LINK3_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    suppressif ideqval SETUP_DATA.SkyCam_Link3 == 0;
      goto STR_144_FORM_ID, // AMI_OVERRIDE  // go to Link3 menu
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        help     = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS),
        flags   = 0,
        key     = 0;
    endif;

    oneof varid     = SETUP_DATA.PchSkyCamPortATermOverride,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_TERM_OVERRIDE),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_TERM_OVERRIDE),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    oneof varid     = SETUP_DATA.PchSkyCamPortBTermOverride,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_TERM_OVERRIDE),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_TERM_OVERRIDE),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    oneof varid     = SETUP_DATA.PchSkyCamPortCTermOverride,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_C_TERM_OVERRIDE),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_C_TERM_OVERRIDE),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
    endoneof;

    oneof varid     = SETUP_DATA.PchSkyCamPortDTermOverride,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_D_TERM_OVERRIDE),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_D_TERM_OVERRIDE),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = SETUP_DATA.PchSkyCamPortACtleEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_CTLE_EN),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_CTLE_EN),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;
    oneof varid   = SETUP_DATA.PchSkyCamPortBCtleEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_CTLE_EN),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_CTLE_EN),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;
    oneof varid   = SETUP_DATA.PchSkyCamPortCDCtleEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_CD_CTLE_EN),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_CD_CTLE_EN),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;

    numeric varid = SETUP_DATA.PchSkyCamPortACtleCapValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_CTLE_CAP_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_CTLE_CAP_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0xE,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortACtleResValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_CTLE_RES_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_CTLE_RES_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0x1F,
      step     = 1,
      default  = 0xD,
    endnumeric;

    numeric varid = SETUP_DATA.PchSkyCamPortBCtleCapValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_CTLE_CAP_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_CTLE_CAP_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0xE,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortBCtleResValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_CTLE_RES_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_CTLE_RES_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0x1F,
      step     = 1,
      default  = 0xD,
    endnumeric;

    numeric varid = SETUP_DATA.PchSkyCamPortCDCtleCapValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_CD_CTLE_CAP_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_CD_CTLE_CAP_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0xE,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortCDCtleResValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_CD_CTLE_RES_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_CD_CTLE_RES_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0x1F,
      step     = 1,
      default  = 0xD,
    endnumeric;

    oneof varid   = SETUP_DATA.PchSkyCamPortATrimEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_TRIM),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_TRIM),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;
    oneof varid   = SETUP_DATA.PchSkyCamPortBTrimEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_TRIM),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_TRIM),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;
    oneof varid   = SETUP_DATA.PchSkyCamPortCTrimEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_C_TRIM),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_C_TRIM),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;
    oneof varid   = SETUP_DATA.PchSkyCamPortDTrimEnable,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_D_TRIM),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_D_TRIM),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  DEFAULT | RESET_REQUIRED;
    endoneof;

    numeric varid = SETUP_DATA.PchSkyCamPortADataTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_DATA_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_DATA_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xFFFF,
      step     = 1,
      default  = 0xBBBB,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortBDataTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_DATA_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_DATA_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xFFFF,
      step     = 1,
      default  = 0xBBBB,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortCDDataTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_CD_DATA_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_CD_DATA_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xFFFF,
      step     = 1,
      default  = 0xCCCC,
    endnumeric;

    numeric varid = SETUP_DATA.PchSkyCamPortAClkTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_A_CLK_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_A_CLK_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0xA,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortBClkTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_B_CLK_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_B_CLK_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0xA,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortCClkTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_C_CLK_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_C_CLK_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0x9,
    endnumeric;
    numeric varid = SETUP_DATA.PchSkyCamPortDClkTrimValue,
      prompt      = STRING_TOKEN(STR_SKYCAM_PORT_D_CLK_TRIM_VAL),
      help        = STRING_TOKEN(STR_SKYCAM_PORT_D_CLK_TRIM_VAL),
      flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
      minimum  = 0,
      maximum  = 0xF,
      step     = 1,
      default  = 0xA,
    endnumeric;

  endform; // End of SKYCAM_CIO2_OPTIONS_FORM_ID

  form formid = AUTO_ID(SCS_OPTIONS_FORM_ID),
    title = STRING_TOKEN(STR_SCS_OPTIONS_FORM_TITLE);

    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0] == 0;
    oneof varid  = PCH_SETUP.PchScsEmmcEnabled,
      prompt   = STRING_TOKEN(STR_SCS_EMMC_CONTROLLER_PROMPT),
      help     = STRING_TOKEN(STR_SCS_EMMC_CONTROLLER_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeA0Rvp3Ppv
//                                                                     BoardIdSkylakeULpddr3Rvp5Ppv
//                                                                     BoardIdSkylakeURvp7Ppv
//                                                                     BoardIdSkylakeSds
//                                                                     BoardIdSkylakeSdlBrk
//                                                                     BoardIdSkylakeDtRvp8Crb
//                                                                     BoardIdSkylakeAioRvp9Crb
//                                                                     BoardIdSkylakeAioRvp10Erb
//                                                                     BoardIdSkylakeAioRvp10Crb
//                                                                     BoardIdSkylakeAioRvp10Evp
//                                                                     BoardIdSkylakeAioRvp10CrbPpv
//                                                                     BoardIdSkylakeHaloDdr4Rvp11
//                                                                     BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     BoardIdSkylakeHaloLpddr3Rvp16
//                                                                     BoardIdKabylakeDdr4Rvp17 // KblGContent
//                                                                   ? 0x1:0x0), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;
    endif;

    suppressif ideqval PCH_SETUP.PchScsEmmcEnabled == 0;
      oneof varid  = PCH_SETUP.PchScsEmmcHs400Enabled,
        prompt   = STRING_TOKEN(STR_SCS_EMMC_HS400_PROMPT),
        help     = STRING_TOKEN(STR_SCS_EMMC_HS400_HELP),
// AMI_OVERRIDE_START                    
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                 ? 1:0), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      grayoutif ideqval PCH_SETUP.PchScsEmmcHs400Enabled == 0;
        oneof varid  = PCH_SETUP.PchScsEmmcHs400DriverStrength,
          prompt   = STRING_TOKEN(STR_SCS_EMMC_HS400_DRV_STRENGTH_PROMPT),
          help     = STRING_TOKEN(STR_SCS_EMMC_HS400_DRV_STRENGTH_HELP),
          option text = STRING_TOKEN(STR_33_OHM), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_40_OHM), value = 1, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
          option text = STRING_TOKEN(STR_50_OHM), value = 2, flags = RESET_REQUIRED;
        endoneof;
      endif;
    endif;

    grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART0] == 0;
    oneof varid  = PCH_SETUP.PchScsSdCardEnabled,
      prompt   = STRING_TOKEN(STR_SCS_SDHC_CONTROLLER_PROMPT),
      help     = STRING_TOKEN(STR_SCS_SDHC_CONTROLLER_HELP),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     BoardIdSkylakeSdlBrk
//                                                                     BoardIdSkylakeDtRvp8Crb
//                                                                     BoardIdSkylakeAioRvp9Crb
//                                                                     BoardIdSkylakeAioRvp10Erb
//                                                                     BoardIdSkylakeAioRvp10Crb
//                                                                     BoardIdSkylakeAioRvp10Evp
//                                                                     BoardIdSkylakeAioRvp10CrbPpv
//                                                                     BoardIdSkylakeHaloDdr4Rvp11
//                                                                     BoardIdSkylakeHaloDdr4Rvp11Ppv
//                                                                     BoardIdSkylakeHaloLpddr3Rvp16
//                                                                     BoardIdKabylakeDdr4Rvp17 // KblGContent
//                                                                    ? 1:0), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
    endoneof;
    endif;

    suppressif ideqval PCH_SETUP.PchScsSdCardEnabled == 0; // SDCard must be enabled for Sideband D3 events support
      oneof varid  = PCH_SETUP.PchScsSdCardSidebandEventsSupport,
        prompt   = STRING_TOKEN(STR_SCS_SDCARD_SIDEBAND_EVENTS_PROMPT),
        help     = STRING_TOKEN(STR_SCS_SDCARD_SIDEBAND_EVENTS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SD_CDB_GPP_B17), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SD_CDB_GPP_D10), value = 2, flags = RESET_REQUIRED;
      endoneof;
    endif;

  endform; // End of SCS_OPTIONS_FORM_ID

  form formid = AUTO_ID(ISH_OPTIONS_FORM_ID),
    title = STRING_TOKEN(STR_ISH_OPTIONS_FORM_TITLE);
    grayoutif ideqval SETUP_DATA.GnssConnection == 2;
    oneof varid  = PCH_SETUP.PchIshEnable,
      prompt   = STRING_TOKEN(STR_ISH_PROMPT),
      help     = STRING_TOKEN(STR_ISH_HELP),
      option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
    endoneof;
    endif;
//ray_override / [XI-Tuning] Arrange Setup Default Setting

    suppressif ideqval PCH_SETUP.PchIshEnable == 0;
      checkbox varid  = PCH_SETUP.PchIshPdtUnlock,
        prompt   = STRING_TOKEN(STR_ISH_PDT_UNLOCK_PROMPT),
        help     = STRING_TOKEN(STR_ISH_PDT_UNLOCK_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;


    // ISH GPIO Assignment
    text
       help   = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
       text   = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_TITLE),
       flags  = 0,
       key    = 0;

      // SPI
      checkbox varid  = PCH_SETUP.PchIshSpiGpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_SPI_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // UART0
      grayoutif NOT ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C2] == 0 AND ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
      checkbox varid  = PCH_SETUP.PchIshUart0GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_UART0_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;
      endif;

      // UART1
      grayoutif ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_UART1] == 1;
      checkbox varid  = PCH_SETUP.PchIshUart1GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_UART1_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;
      endif;

      // I2C0
      checkbox varid  = PCH_SETUP.PchIshI2c0GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_I2C0_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // I2C1
      checkbox varid  = PCH_SETUP.PchIshI2c1GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_I2C1_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // I2C2
      grayoutif (NOT ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C5] == 0 AND ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx) OR
                (NOT ideqval PCH_SETUP.PchSerialIoDevice[SERIAL_IO_I2C3] == 0 AND ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad);
      checkbox varid  = PCH_SETUP.PchIshI2c2GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_I2C2_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;
      endif;

      // GP_0
      checkbox varid  = PCH_SETUP.PchIshGp0GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP0_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_1
      checkbox varid  = PCH_SETUP.PchIshGp1GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP1_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_2
      checkbox varid  = PCH_SETUP.PchIshGp2GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP2_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_3
      checkbox varid  = PCH_SETUP.PchIshGp3GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP3_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_4
      checkbox varid  = PCH_SETUP.PchIshGp4GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP4_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_5
      checkbox varid  = PCH_SETUP.PchIshGp5GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP5_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_6
      checkbox varid  = PCH_SETUP.PchIshGp6GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP6_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;

      // GP_7
      checkbox varid  = PCH_SETUP.PchIshGp7GpioAssign,
        prompt   = STRING_TOKEN(STR_ISH_GPIO_GP7_PROMPT),
        help     = STRING_TOKEN(STR_ISH_GPIO_ASSIGN_HELP),
        flags    = 0 | RESET_REQUIRED,
        key      = 0,
      endcheckbox;
    endif; // suppressif PchIshEnable == 0;
  endform; // End of ISH_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_TRACE_HUB_OPTIONS_FORM_ID),
    title = STRING_TOKEN(STR_TRACE_HUB_CONFIG_TITLE);

    oneof varid  = PCH_SETUP.TraceHubEnableMode,
      prompt   = STRING_TOKEN(STR_TRACE_HUB_ENABLED),
      help     = STRING_TOKEN(STR_TRACE_HUB_ENABLED_HELP),
      option text = STRING_TOKEN(STR_TRACE_HUB_DISABLE),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_HOST_DEBUGGER), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid  = PCH_SETUP.MemRegion0BufferSize,
      prompt   = STRING_TOKEN(STR_TRACE_HUB_MEM_REGION_0_SIZE),
      help     = STRING_TOKEN(STR_TRACE_HUB_MEM_REGION_0_HELP),
      option text = STRING_TOKEN(STR_TRACE_HUB_NONE),   value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_1MB),   value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_8MB),   value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_64MB),  value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_128MB), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_256MB), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_512MB), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_1GB),   value = 7, flags = RESET_REQUIRED;
    endoneof;

    oneof varid  = PCH_SETUP.MemRegion1BufferSize,
      prompt   = STRING_TOKEN(STR_TRACE_HUB_MEM_REGION_1_SIZE),
      help     = STRING_TOKEN(STR_TRACE_HUB_MEM_REGION_1_HELP),
      option text = STRING_TOKEN(STR_TRACE_HUB_NONE),   value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_1MB),   value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_8MB),   value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_64MB),  value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_128MB), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_256MB), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_512MB), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_TRACE_HUB_1GB),   value = 7, flags = RESET_REQUIRED;
    endoneof;

  endform; // End of PCH_TRACE_HUB_OPTIONS_FORM_ID

  form formid = AUTO_ID(PCH_THERMAL_THROTTLING_OPTIONS_FORM_ID),
    title = STRING_TOKEN(STR_PCH_THERMAL_THROTTLING);
      oneof varid  = PCH_SETUP.PchTtLevelSuggestSet,
        prompt   = STRING_TOKEN(STR_PCH_THRM_TTLVL_SET_PROMPT),
        help     = STRING_TOKEN(STR_PCH_THRM_TTLVL_SET_HELP),
        option text = STRING_TOKEN(STR_SUGGEST_SETTING), value = 1, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MANUAL), value = 0, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchTtLevelSuggestSet == 1;
        checkbox varid  = PCH_SETUP.PchThrmTtEnable,
         prompt   = STRING_TOKEN(STR_PCH_THRM_TT_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_TT_HELP),
         // Flags behavior for checkbox is overloaded so that it equals
         // a DEFAULT value.  1 = ON, 0 = off
         flags    = 0 | RESET_REQUIRED,
         key      = 0,
        endcheckbox;

        checkbox varid  = PCH_SETUP.PchThrmTtState13Enable,
         prompt   = STRING_TOKEN(STR_PCH_THRM_TT13_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_TT13_HELP),
         // Flags behavior for checkbox is overloaded so that it equals
         // a DEFAULT value.  1 = ON, 0 = off
         flags    = 0 | RESET_REQUIRED,
         key      = 0,
        endcheckbox;

        checkbox varid  = PCH_SETUP.PchThrmTtLock,
         prompt   = STRING_TOKEN(STR_PCH_THRM_TT_LOCK_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_TT_LOCK_HELP),
         // Flags behavior for checkbox is overloaded so that it equals
         // a DEFAULT value.  1 = ON, 0 = off
         flags    = 0 | RESET_REQUIRED,
         key      = 0,
        endcheckbox;

        numeric varid = PCH_SETUP.PchThrmT0Level,
         prompt    = STRING_TOKEN(STR_PCH_THRM_T0_LVL_PROMPT),
         help      = STRING_TOKEN(STR_PCH_THRM_T0_LVL_HELP),
         flags     = RESET_REQUIRED,
         minimum   = 0,
         maximum   = 65535,
         step      = 1,
         default   = 0,
        endnumeric;

        numeric varid = PCH_SETUP.PchThrmT1Level,
         prompt    = STRING_TOKEN(STR_PCH_THRM_T1_LVL_PROMPT),
         help      = STRING_TOKEN(STR_PCH_THRM_T1_LVL_HELP),
         flags     = RESET_REQUIRED,
         minimum   = 0,
         maximum   = 65535,
         step      = 1,
         default   = 0,
        endnumeric;

        numeric varid = PCH_SETUP.PchThrmT2Level,
         prompt    = STRING_TOKEN(STR_PCH_THRM_T2_LVL_PROMPT),
         help      = STRING_TOKEN(STR_PCH_THRM_T2_LVL_HELP),
         flags     = RESET_REQUIRED,
         minimum   = 0,
         maximum   = 65535,
         step      = 1,
         default   = 0,
        endnumeric;
      endif;

      oneof varid  = PCH_SETUP.PchDmiTsSuggestSet,
         prompt   = STRING_TOKEN(STR_PCH_THRM_DMI_SET_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_DMI_SET_HELP),
         option text = STRING_TOKEN(STR_SUGGEST_SETTING), value = 1, flags = DEFAULT | RESET_REQUIRED;
         option text = STRING_TOKEN(STR_MANUAL), value = 0, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchDmiTsSuggestSet == 1;
        checkbox varid  = PCH_SETUP.PchDmiTsawEn,
         prompt   = STRING_TOKEN(STR_PCH_THRM_DMI_TSW_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_DMI_TSW_HELP),
         // Flags behavior for checkbox is overloaded so that it equals
         // a DEFAULT value.  1 = ON, 0 = off
         flags    = 0 | RESET_REQUIRED,
         key      = 0,
        endcheckbox;

        oneof varid  = PCH_SETUP.PchTs0Width,
         prompt   = STRING_TOKEN(STR_PCH_THRM_TS0W_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_TS0W_HELP),
         option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 0, flags = DEFAULT | RESET_REQUIRED;
         option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 1, flags = RESET_REQUIRED;
         option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 2, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchTs1Width,
          prompt   = STRING_TOKEN(STR_PCH_THRM_TS1W_PROMPT),
          help     = STRING_TOKEN(STR_PCH_THRM_TS1W_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 2, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchTs2Width,
          prompt   = STRING_TOKEN(STR_PCH_THRM_TS2W_PROMPT),
          help     = STRING_TOKEN(STR_PCH_THRM_TS2W_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 2, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchTs3Width,
          prompt   = STRING_TOKEN(STR_PCH_THRM_TS3W_PROMPT),
          help     = STRING_TOKEN(STR_PCH_THRM_TS3W_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 2, flags = RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid  = PCH_SETUP.PchSataTsSuggestSet,
         prompt   = STRING_TOKEN(STR_PCH_THRM_SATA_SET_PROMPT),
         help     = STRING_TOKEN(STR_PCH_THRM_SATA_SET_HELP),
         option text = STRING_TOKEN(STR_SUGGEST_SETTING), value = 1, flags = DEFAULT | RESET_REQUIRED;
         option text = STRING_TOKEN(STR_MANUAL), value = 0, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval PCH_SETUP.PchSataTsSuggestSet == 1;
        subtitle text = STRING_TOKEN(STR_PCH_SATA_PORT_0);
        oneof varid  = PCH_SETUP.PchP0T1M,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXT1M_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXT1M_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 1, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP0T2M,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXT2M_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXT2M_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 2, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP0T3M,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXT3M_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXT3M_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 3, flags = DEFAULT | RESET_REQUIRED;
        endoneof;

        checkbox varid  = PCH_SETUP.PchP0TDispFinit,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTDISPFINIT_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTDISPFINIT_HELP),
          // Flags behavior for checkbox is overloaded so that it equals
          // a DEFAULT value.  1 = ON, 0 = off
          flags    = 0 | RESET_REQUIRED,
          key      = 0,
        endcheckbox;
      endif;

      suppressif ideqval PCH_SETUP.PchP0TDispFinit == 0 OR ideqval PCH_SETUP.PchSataTsSuggestSet == 1;
        oneof varid  = PCH_SETUP.PchP0TDisp,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTDISP_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTDISP_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_8), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP0Tinact,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTINACT_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTINACT_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_8), value = 3, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.PchP0TDispFinit == 1 OR ideqval PCH_SETUP.PchSataTsSuggestSet == 1;
        oneof varid  = PCH_SETUP.PchP0TDisp,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTDISP_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTDISP_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_8), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP0Tinact,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTINACT_PROMPT0),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTINACT_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_8), value = 3, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.PchSataTsSuggestSet == 1;
        subtitle text = STRING_TOKEN(STR_PCH_SATA_PORT_1);
        oneof varid  = PCH_SETUP.PchP1T1M,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXT1M_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXT1M_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 1, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP1T2M,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXT2M_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXT2M_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 2, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP1T3M,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXT3M_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXT3M_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TS_WIDTH_X4), value = 3, flags = DEFAULT | RESET_REQUIRED;
        endoneof;

        checkbox varid  = PCH_SETUP.PchP1TDispFinit,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTDISPFINIT_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTDISPFINIT_HELP),
          // Flags behavior for checkbox is overloaded so that it equals
          // a DEFAULT value.  1 = ON, 0 = off
          flags    = 0 | RESET_REQUIRED,
          key      = 0,
        endcheckbox;
      endif;

      suppressif ideqval PCH_SETUP.PchP1TDispFinit == 0 OR ideqval PCH_SETUP.PchSataTsSuggestSet == 1;
        oneof varid  = PCH_SETUP.PchP1TDisp,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTDISP_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTDISP_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_8), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP1Tinact,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTINACT_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTINACT_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_FI_8), value = 3, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval PCH_SETUP.PchP1TDispFinit == 1 OR ideqval PCH_SETUP.PchSataTsSuggestSet == 1;
        oneof varid  = PCH_SETUP.PchP1TDisp,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTDISP_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTDISP_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_8), value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = PCH_SETUP.PchP1Tinact,
          prompt   = STRING_TOKEN(STR_PCH_THRM_PXTINACT_PROMPT1),
          help     = STRING_TOKEN(STR_PCH_THRM_PXTINACT_HELP),
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_32), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_128), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_THRM_TIME_8), value = 3, flags = RESET_REQUIRED;
        endoneof;
      endif;

    endform; // End of PCH_THERMAL_THROTTLING_OPTIONS_FORM_ID

  // *********************************************************
  form formid = AUTO_ID(STR_141_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS);
    subtitle text = STRING_TOKEN(STR_SKYCAM_LINK0_SUBTITLE);

    oneof varid   = SETUP_DATA.SkyCam_Link0_SensorModel,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_SENSOR_MODEL),
      help        = STRING_TOKEN(STR_SKYCAM_SENSOR_MODEL),
      option text = STRING_TOKEN(STR_SKYCAM_IMX135), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5693), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX179), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8858), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9728), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX188), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX208), value = 7, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5670), value = 8, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8865), value = 9, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_HM2051), value = 10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2742), value = 11, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9234), value = 12, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8856), value = 13, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV16860), value = 14, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_USER), value = 255, flags = RESET_REQUIRED;
    endoneof;

    // User defined _HID for Link0
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link0_SensorModel == 255;
       string varid = SETUP_DATA.SkyCam_Link0_UserHid,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_CUSTOM_HID),
        help     = STRING_TOKEN(STR_SKYCAM_CUSTOM_HID),
        minsize  = 6,
        maxsize  = 8,
      endstring;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_LanesClkDiv,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_LANES_CLK_DIV),
      help        = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_Link0_DriverData_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    // Control Logic
    oneof varid = SETUP_DATA.SkyCam_Link0_DriverData_ControlLogic,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_GPIO_CONTROL),
      help     = STRING_TOKEN(STR_SKYCAM_GPIO_CONTROL),
// AMI_OVERRIDE_START
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                 ? 0xFF:0), defaultstore = MyStandardDefault,
//      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = RESET_REQUIRED;
// AMI_OVERRIDE_END
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
      endif
    endoneof;

    // Physical location
    oneof varid     = SETUP_DATA.SkyCam_Link0_CameraPhysicalLocation,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_LOCATION),
      help        = STRING_TOKEN(STR_SKYCAM_LOCATION),
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    // Flash support
    oneof varid     = SETUP_DATA.SkyCam_Link0_DriverData_FlashSupport,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_FLASH_SUPPORT),
      help        = STRING_TOKEN(STR_SKYCAM_FLASH_SUPPORT),
// AMI_OVERRIDE_START
//      default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x0:0x3), defaultstore = MyStandardDefault,
// AMI_OVERRIDE_END
      option text = STRING_TOKEN(STR_SKYCAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
    endoneof;

    // Privacy LED
    oneof varid   = SETUP_DATA.SkyCamLink0DriverDataPrivacyLed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_PRIVACY_LED),
      help        = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED),
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
    endoneof;

    // Rotation
    oneof varid     = SETUP_DATA.SkyCam_Link0_DriverData_Degree,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_DEGREE),
      help        = STRING_TOKEN(STR_SKYCAM_DEGREE),
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
    endoneof;

    // PMIC Position
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link0_DriverData_CrdVersion == 0x50;
      oneof varid   = SETUP_DATA.SkyCamLink0DriverDataPmicPosition,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_PMIC_POSITION),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION),
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Voltage Rail
    suppressif NOT ideqval SETUP_DATA.SkyCamLink0DriverDataPmicPosition == 1;
      oneof varid   = SETUP_DATA.SkyCamLink0DriverDataVoltageRail,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_VOLTAGE_RAIL),
        help        = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL),
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Camera Module Name
    grayoutif ideqval SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds;
    string varid    = SETUP_DATA.SkyCam_Link0_ModuleName,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_MODULE_NAME),
      help     = STRING_TOKEN(STR_SKYCAM_MODULE_NAME),
      minsize  = 1,
      maxsize  = 15,
    endstring;
    endif;

    // Lane Used
    oneof varid     = SETUP_DATA.SkyCam_Link0_DriverData_LaneUsed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_SDD_LANE_USED),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_LANE_USED),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X8), value = 8, flags = RESET_REQUIRED;
    endoneof;

    // MCLK
    oneof varid     = SETUP_DATA.SkyCam_Link0_DriverData_Mclk,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_SDD_MCLK),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_MCLK),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_19_2), value = 0x0124F800, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_24), value = 0x016E3600, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_20), value = 0x01312D00, flags = RESET_REQUIRED;
    endoneof;

    // EEPROM Type
    oneof varid     = SETUP_DATA.SkyCam_Link0_DriverData_EepromType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_SDD_EEPROM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED1), value = 0x09, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED2), value = 0x0A, flags = RESET_REQUIRED;
    endoneof;

    // VCM Type
    oneof varid     = SETUP_DATA.SkyCam_Link0_DriverData_VcmType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_SDD_VCM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_VCM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5823), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9714), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5816), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9719), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9718), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED1), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED2), value = 0x07, flags = RESET_REQUIRED;
    endoneof;

    // I2C devices
    numeric varid     = SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK0_DEVICES_I2C),
      help        = STRING_TOKEN(STR_SKYCAM_DEVICES_I2C),
      flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
      minimum  = 0,
      maximum  = 12,
      step     = 1,
      default  = 6,
    endnumeric;

    suppressif ideqval SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0;
      // I2C channel
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cChannel,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C Device 0
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE0);

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS0),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x10,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE0),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif ;

    // I2C Device 1
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE1);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS1),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x0E,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE1),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 2
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE2);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS2),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x50,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE2),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 3
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE3);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS3),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x51,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE3),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 4
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE4);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS4),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x52,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE4),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 5
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE5);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS5),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x53,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE5),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 6
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE6);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS6),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x54,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE6),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 7
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE7);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS7),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x55,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE7),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 8
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE8);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS8),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x56,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE8),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 9
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE9);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS9),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x57,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE9),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 10
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE10);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS10),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x58,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE10),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 11
    suppressif ideqvallist SETUP_DATA.SkyCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE11);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link0_I2cAddress[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_ADDRESS11),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x59,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link0_I2cDeviceType[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK0_I2C_DEVICE_TYPE11),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;
  endform;

  // *********************************************************
  form formid = AUTO_ID(STR_142_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS);
    subtitle text = STRING_TOKEN(STR_SKYCAM_LINK1_SUBTITLE);

    oneof varid   = SETUP_DATA.SkyCam_Link1_SensorModel,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_SENSOR_MODEL),
      help        = STRING_TOKEN(STR_SKYCAM_SENSOR_MODEL),
      option text = STRING_TOKEN(STR_SKYCAM_IMX135), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5693), value = 1, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX179), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8858), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9728), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX188), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX208), value = 7, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5670), value = 8, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8865), value = 9, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_HM2051), value = 10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2742), value = 11, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9234), value = 12, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8856), value = 13, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV16860), value = 14, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_USER), value = 255, flags = RESET_REQUIRED;
    endoneof;

    // User defined _HID for Link1
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link1_SensorModel == 255;
       string varid = SETUP_DATA.SkyCam_Link1_UserHid,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_CUSTOM_HID),
        help     = STRING_TOKEN(STR_SKYCAM_CUSTOM_HID),
        minsize  = 6,
        maxsize  = 8,
      endstring;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_LanesClkDiv,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_LANES_CLK_DIV),
      help        = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_Link1_DriverData_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    // Control Logic
    oneof varid = SETUP_DATA.SkyCam_Link1_DriverData_ControlLogic,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_GPIO_CONTROL),
      help     = STRING_TOKEN(STR_SKYCAM_GPIO_CONTROL),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
      endif
    endoneof;

    // Physical location
    oneof varid     = SETUP_DATA.SkyCam_Link1_CameraPhysicalLocation,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_LOCATION),
      help        = STRING_TOKEN(STR_SKYCAM_LOCATION),
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x61, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x69, flags = RESET_REQUIRED;
    endoneof;

    // Flash support
    oneof varid     = SETUP_DATA.SkyCam_Link1_DriverData_FlashSupport,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_FLASH_SUPPORT),
      help        = STRING_TOKEN(STR_SKYCAM_FLASH_SUPPORT),
      option text = STRING_TOKEN(STR_SKYCAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
    endoneof;

    // Privacy LED
    oneof varid   = SETUP_DATA.SkyCamLink1DriverDataPrivacyLed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_PRIVACY_LED),
      help        = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED),
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
    endoneof;

    // Rotation
    oneof varid     = SETUP_DATA.SkyCam_Link1_DriverData_Degree,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_DEGREE),
      help        = STRING_TOKEN(STR_SKYCAM_DEGREE),
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
    endoneof;

    // PMIC Position
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link1_DriverData_CrdVersion == 0x50;
      oneof varid   = SETUP_DATA.SkyCamLink1DriverDataPmicPosition,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_PMIC_POSITION),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION),
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Voltage Rail
    suppressif NOT ideqval SETUP_DATA.SkyCamLink1DriverDataPmicPosition == 1;
      oneof varid   = SETUP_DATA.SkyCamLink1DriverDataVoltageRail,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_VOLTAGE_RAIL),
        help        = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL),
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Camera Module Name
    string varid    = SETUP_DATA.SkyCam_Link1_ModuleName,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_MODULE_NAME),
      help     = STRING_TOKEN(STR_SKYCAM_MODULE_NAME),
      minsize  = 1,
      maxsize  = 15,
    endstring;

    // Lane Used
    oneof varid     = SETUP_DATA.SkyCam_Link1_DriverData_LaneUsed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_SDD_LANE_USED),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_LANE_USED),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X2), value = 2, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X4), value = 4, flags = RESET_REQUIRED;
    endoneof;

    // MCLK
    oneof varid     = SETUP_DATA.SkyCam_Link1_DriverData_Mclk,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_SDD_MCLK),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_MCLK),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_19_2), value = 0x0124F800, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_24), value = 0x016E3600, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_20), value = 0x01312D00, flags = RESET_REQUIRED;
    endoneof;

    // EEPROM Type
    oneof varid     = SETUP_DATA.SkyCam_Link1_DriverData_EepromType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_SDD_EEPROM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED1), value = 0x09, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED2), value = 0x0A, flags = RESET_REQUIRED;
    endoneof;

    // VCM Type
    oneof varid     = SETUP_DATA.SkyCam_Link1_DriverData_VcmType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_SDD_VCM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_VCM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5823), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9714), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5816), value = 0x03, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9719), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9718), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED1), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED2), value = 0x07, flags = RESET_REQUIRED;
    endoneof;


    // I2C devices
    numeric varid     = SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK1_DEVICES_I2C),
      help        = STRING_TOKEN(STR_SKYCAM_DEVICES_I2C),
      flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
      minimum  = 0,
      maximum  = 12,
      step     = 1,
      default  = 6,
    endnumeric;

    suppressif ideqval SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0;
      // I2C channel
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cChannel,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C Device 0
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE0);

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS0),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x10,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE0),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif ;

    // I2C Device 1
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE1);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS1),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x0C,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE1),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 2
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE2);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS2),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x50,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE2),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 3
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE3);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS3),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x51,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE3),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 4
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE4);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS4),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x52,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE4),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 5
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE5);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS5),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x53,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE5),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 6
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE6);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS6),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x54,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE6),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 7
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE7);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS7),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x55,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE7),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 8
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE8);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS8),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x56,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE8),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 9
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE9);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS9),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x57,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE9),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 10
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE10);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS10),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x58,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE10),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 11
    suppressif ideqvallist SETUP_DATA.SkyCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE11);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link1_I2cAddress[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_ADDRESS11),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x59,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link1_I2cDeviceType[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK1_I2C_DEVICE_TYPE11),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = DEFAULT | RESET_REQUIRED;
      endoneof;
    endif;
  endform;

  // *********************************************************
  form formid = AUTO_ID(STR_143_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS);
    subtitle text = STRING_TOKEN(STR_SKYCAM_LINK2_SUBTITLE);

    oneof varid   = SETUP_DATA.SkyCam_Link2_SensorModel,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_SENSOR_MODEL),
      help        = STRING_TOKEN(STR_SKYCAM_SENSOR_MODEL),
      option text = STRING_TOKEN(STR_SKYCAM_IMX135), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5693), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX179), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8858), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9728), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX188), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX208), value = 7, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5670), value = 8, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8865), value = 9, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_HM2051), value = 10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2742), value = 11, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9234), value = 12, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8856), value = 13, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV16860), value = 14, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_USER), value = 255, flags = RESET_REQUIRED;
    endoneof;

    // User defined _HID for Link2
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link2_SensorModel == 255;
       string varid = SETUP_DATA.SkyCam_Link2_UserHid,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_CUSTOM_HID),
        help     = STRING_TOKEN(STR_SKYCAM_CUSTOM_HID),
        minsize  = 6,
        maxsize  = 8,
      endstring;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_LanesClkDiv,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_LANES_CLK_DIV),
      help        = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_Link2_DriverData_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    // Control Logic
    oneof varid = SETUP_DATA.SkyCam_Link2_DriverData_ControlLogic,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_GPIO_CONTROL),
      help     = STRING_TOKEN(STR_SKYCAM_GPIO_CONTROL),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
      endif
    endoneof;

    // Physical location
    oneof varid     = SETUP_DATA.SkyCam_Link2_CameraPhysicalLocation,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_LOCATION),
      help        = STRING_TOKEN(STR_SKYCAM_LOCATION),
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    // Flash support
    oneof varid     = SETUP_DATA.SkyCam_Link2_DriverData_FlashSupport,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_FLASH_SUPPORT),
      help        = STRING_TOKEN(STR_SKYCAM_FLASH_SUPPORT),
      option text = STRING_TOKEN(STR_SKYCAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
    endoneof;

    // Privacy LED
    oneof varid   = SETUP_DATA.SkyCamLink2DriverDataPrivacyLed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_PRIVACY_LED),
      help        = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED),
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
    endoneof;

    // Rotation
    oneof varid     = SETUP_DATA.SkyCam_Link2_DriverData_Degree,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_DEGREE),
      help        = STRING_TOKEN(STR_SKYCAM_DEGREE),
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
    endoneof;

    // PMIC Position
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link2_DriverData_CrdVersion == 0x50;
      oneof varid   = SETUP_DATA.SkyCamLink2DriverDataPmicPosition,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_PMIC_POSITION),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION),
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Voltage Rail
    suppressif NOT ideqval SETUP_DATA.SkyCamLink2DriverDataPmicPosition == 1;
      oneof varid   = SETUP_DATA.SkyCamLink2DriverDataVoltageRail,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_VOLTAGE_RAIL),
        help        = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL),
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Camera Module Name
    string varid    = SETUP_DATA.SkyCam_Link2_ModuleName,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_MODULE_NAME),
      help     = STRING_TOKEN(STR_SKYCAM_MODULE_NAME),
      minsize  = 1,
      maxsize  = 15,
    endstring;

    // Lane Used
    oneof varid     = SETUP_DATA.SkyCam_Link2_DriverData_LaneUsed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_SDD_LANE_USED),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_LANE_USED),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    // MCLK
    oneof varid     = SETUP_DATA.SkyCam_Link2_DriverData_Mclk,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_SDD_MCLK),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_MCLK),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_19_2), value = 0x0124F800, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_24), value = 0x016E3600, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_20), value = 0x01312D00, flags = RESET_REQUIRED;
    endoneof;

    // EEPROM Type
    oneof varid     = SETUP_DATA.SkyCam_Link2_DriverData_EepromType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_SDD_EEPROM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED1), value = 0x09, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED2), value = 0x0A, flags = RESET_REQUIRED;
    endoneof;

    // VCM Type
    oneof varid     = SETUP_DATA.SkyCam_Link2_DriverData_VcmType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_SDD_VCM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_VCM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5823), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9714), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5816), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9719), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9718), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED1), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED2), value = 0x07, flags = RESET_REQUIRED;
    endoneof;


    // I2C devices
    numeric varid     = SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK2_DEVICES_I2C),
      help        = STRING_TOKEN(STR_SKYCAM_DEVICES_I2C),
      flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
      minimum  = 0,
      maximum  = 12,
      step     = 1,
      default  = 6,
    endnumeric;

    suppressif ideqval SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0;
      // I2C channel
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cChannel,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C Device 0
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE0);

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS0),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x10,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE0),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif ;

    // I2C Device 1
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE1);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS1),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x0E,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE1),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 2
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE2);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS2),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x50,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE2),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 3
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE3);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS3),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x51,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE3),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 4
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE4);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS4),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x52,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE4),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 5
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE5);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS5),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x53,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE5),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 6
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE6);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS6),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x54,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE6),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 7
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE7);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS7),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x55,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE7),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 8
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE8);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS8),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x56,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE8),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 9
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE9);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS9),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x57,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE9),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 10
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE10);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS10),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x58,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE10),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 11
    suppressif ideqvallist SETUP_DATA.SkyCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE11);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link2_I2cAddress[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_ADDRESS11),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x59,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link2_I2cDeviceType[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK2_I2C_DEVICE_TYPE11),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;
  endform;

  // *********************************************************
  form formid = AUTO_ID(STR_144_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_LINK_OPTIONS);
    subtitle text = STRING_TOKEN(STR_SKYCAM_LINK3_SUBTITLE);

    oneof varid   = SETUP_DATA.SkyCam_Link3_SensorModel,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_SENSOR_MODEL),
      help        = STRING_TOKEN(STR_SKYCAM_SENSOR_MODEL),
      option text = STRING_TOKEN(STR_SKYCAM_IMX135), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5693), value = 1, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX179), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8858), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9728), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX188), value = 6, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_IMX208), value = 7, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV5670), value = 8, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8865), value = 9, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_HM2051), value = 10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV2742), value = 11, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV9234), value = 12, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV8856), value = 13, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_OV16860), value = 14, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_USER), value = 255, flags = RESET_REQUIRED;
    endoneof;

    // User defined _HID for Link3
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link3_SensorModel == 255;
       string varid = SETUP_DATA.SkyCam_Link3_UserHid,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_CUSTOM_HID),
        help     = STRING_TOKEN(STR_SKYCAM_CUSTOM_HID),
        minsize  = 6,
        maxsize  = 8,
      endstring;
    endif;

    oneof varid     = SETUP_DATA.SkyCam_LanesClkDiv,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_LANES_CLK_DIV),
      help        = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_Link3_DriverData_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    // Control Logic
    oneof varid = SETUP_DATA.SkyCam_Link3_DriverData_ControlLogic,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_GPIO_CONTROL),
      help     = STRING_TOKEN(STR_SKYCAM_GPIO_CONTROL),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
      endif
      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3 == 0;
        option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
      endif
    endoneof;

    // Physical location
    oneof varid     = SETUP_DATA.SkyCam_Link3_CameraPhysicalLocation,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_LOCATION),
      help        = STRING_TOKEN(STR_SKYCAM_LOCATION),
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    // Flash support
    oneof varid     = SETUP_DATA.SkyCam_Link3_DriverData_FlashSupport,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_FLASH_SUPPORT),
      help        = STRING_TOKEN(STR_SKYCAM_FLASH_SUPPORT),
      option text = STRING_TOKEN(STR_SKYCAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
    endoneof;

    // Privacy LED
    oneof varid   = SETUP_DATA.SkyCamLink3DriverDataPrivacyLed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_PRIVACY_LED),
      help        = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED),
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
    endoneof;

    // Rotation
    oneof varid     = SETUP_DATA.SkyCam_Link3_DriverData_Degree,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_DEGREE),
      help        = STRING_TOKEN(STR_SKYCAM_DEGREE),
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
      //option text = STRING_TOKEN(STR_SKYCAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
    endoneof;

    // PMIC Position
    suppressif NOT ideqval SETUP_DATA.SkyCam_Link3_DriverData_CrdVersion == 0x50;
      oneof varid   = SETUP_DATA.SkyCamLink3DriverDataPmicPosition,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_PMIC_POSITION),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION),
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Voltage Rail
    suppressif NOT ideqval SETUP_DATA.SkyCamLink3DriverDataPmicPosition == 1;
      oneof varid   = SETUP_DATA.SkyCamLink3DriverDataVoltageRail,
        prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_VOLTAGE_RAIL),
        help        = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL),
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // Camera Module Name
    string varid    = SETUP_DATA.SkyCam_Link3_ModuleName,
      prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_MODULE_NAME),
      help     = STRING_TOKEN(STR_SKYCAM_MODULE_NAME),
      minsize  = 1,
      maxsize  = 15,
    endstring;

    // Lane Used
    oneof varid     = SETUP_DATA.SkyCam_Link3_DriverData_LaneUsed,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_SDD_LANE_USED),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_LANE_USED),
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
    endoneof;

    // MCLK
    oneof varid     = SETUP_DATA.SkyCam_Link3_DriverData_Mclk,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_SDD_MCLK),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_MCLK),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_19_2), value = 0x0124F800, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_24), value = 0x016E3600, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_MCLK_20), value = 0x01312D00, flags = RESET_REQUIRED;
    endoneof;

    // EEPROM Type
    oneof varid     = SETUP_DATA.SkyCam_Link3_DriverData_EepromType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_SDD_EEPROM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED1), value = 0x09, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_EEPROM_RESERVED2), value = 0x0A, flags = RESET_REQUIRED;
    endoneof;

    // VCM Type
    oneof varid     = SETUP_DATA.SkyCam_Link3_DriverData_VcmType,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_SDD_VCM_TYPE),
      help        = STRING_TOKEN(STR_SKYCAM_SDD_VCM_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_NONE), value = 0x00, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5823), value = 0x01, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9714), value = 0x02, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_AD5816), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9719), value = 0x04, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_DW9718), value = 0x05, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED1), value = 0x06, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_VCM_RESERVED2), value = 0x07, flags = RESET_REQUIRED;
    endoneof;


    // I2C devices
    numeric varid     = SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled,
      prompt      = STRING_TOKEN(STR_SKYCAM_LINK3_DEVICES_I2C),
      help        = STRING_TOKEN(STR_SKYCAM_DEVICES_I2C),
      flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
      minimum  = 0,
      maximum  = 12,
      step     = 1,
      default  = 6,
    endnumeric;

    suppressif ideqval SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0;
      // I2C channel
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cChannel,
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C Device 0
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE0);

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS0),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x10,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[0],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE0),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif ;

    // I2C Device 1
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE1);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS1),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x0C,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[1],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE1),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 2
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE2);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS2),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x50,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[2],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE2),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 3
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE3);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS3),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x51,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[3],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE3),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 4
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE4);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS4),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x52,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[4],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE4),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 5
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE5);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS5),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x53,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[5],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE5),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 6
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE6);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS6),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x54,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[6],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE6),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 7
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE7);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS7),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x55,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[7],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE7),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 8
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE8);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS8),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x56,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[8],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE8),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 9
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE9);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS9),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x57,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[9],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE9),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 10
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE10);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS10),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x58,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[10],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE10),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
      endoneof;
    endif;

    // I2C Device 11
    suppressif ideqvallist SETUP_DATA.SkyCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
      subtitle text = STRING_TOKEN(STR_SKYCAM_DEVICE11);
      // I2C address
      numeric varid = SETUP_DATA.SkyCam_Link3_I2cAddress[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_ADDRESS11),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x59,
      endnumeric;
      // I2C device type
      oneof varid = SETUP_DATA.SkyCam_Link3_I2cDeviceType[11],
        prompt   = STRING_TOKEN(STR_SKYCAM_LINK3_I2C_DEVICE_TYPE11),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE),
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = DEFAULT | RESET_REQUIRED;
      endoneof;
    endif;
  endform;

  // *********************************************************
  form formid = AUTO_ID(STR_145_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_TITLE1);
    subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_SUBTITLE1);

    // Type of logic
    oneof varid = SETUP_DATA.SkyCam_ControlLogic0_Type,
      prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC0_TYPE),
      help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_ControlLogic0_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_CL0_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic0_CrdVersion == 0x30 0x50;
      // PMIC Flash Panel
      oneof varid   = SETUP_DATA.SkyCam_ControlLogic0_Pld,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL0_PMIC_FLASH_PANEL),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_FLASH_PANEL),
// AMI_OVERRIDE_START
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                     ? 0x21:0x29), defaultstore = MyStandardDefault,
        default value = 0x21,
// AMI_OVERRIDE_END
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x21, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x29, flags = RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0_Type == 1;
      // show below options when PMIC is used
      // I2C Channel
      oneof varid = SETUP_DATA.SkyCam_ControlLogic0_I2cChannel,
        prompt   = STRING_TOKEN(STR_SKYCAM_CL0_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_ControlLogic0_I2cAddress,
        prompt   = STRING_TOKEN(STR_SKYCAM_CL0_I2C_ADDRESS_MAIN),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
// AMI_OVERRIDE_START
//        default value = cond(ideqvallist SETUP_VOLATILE_DATA.PlatId == BoardIdSkylakeSds
//                                                                      ? 0x4D:0x4C), defaultstore = MyStandardDefault,
        default value = 0x4D,
// AMI_OVERRIDE_END
      endnumeric;

      suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic0_Type == 2 3;
        // WLED1 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic0Wled1Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL0_WLED1_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED1 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic0Wled1FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL0_WLED1_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED1 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic0Wled1TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL0_WLED1_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic0Wled2Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL0_WLED2_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED2 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic0Wled2FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL0_WLED2_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic0Wled2TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL0_WLED2_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;
      endif;
    endif;

    suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic0_Type == 2 3 4;
      // show below options when DISCRETE is used
      // Number of GPIO pins enabled
      numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioPinsEnabled,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_PIN_COUNT),
        help        = STRING_TOKEN(STR_SKYCAM_GPIO_PIN_COUNT),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 4,
        step     = 1,
        default  = 2,
      endnumeric;

      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic0_GpioPinsEnabled == 0;
      // GPIO Pin 0
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_0);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupPadNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_PAD_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 22,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioFunction[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_FUNCTION0),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioActiveValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_ACTIVE_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioInitialValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_INITIAL_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;

      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic0_GpioPinsEnabled == 0 1;
        // GPIO Pin 1
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_1);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupPadNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_PAD_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioFunction[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_FUNCTION1),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioActiveValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_ACTIVE_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioInitialValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_INITIAL_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic0_GpioPinsEnabled == 0 1 2;
        // GPIO Pin 2
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_2);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupPadNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_PAD_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioFunction[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_FUNCTION2),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioActiveValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_ACTIVE_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioInitialValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_INITIAL_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;


      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic0_GpioPinsEnabled == 0 1 2 3;
        // GPIO Pin 3
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_3);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupPadNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_PAD_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioGroupNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_GROUP_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic0_GpioFunction[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_FUNCTION3),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioActiveValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_ACTIVE_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic0_GpioInitialValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL0_GPIO_INITIAL_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;
    endif ;
  endform;

  // *********************************************************
  form formid = AUTO_ID(STR_146_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_TITLE2);
    subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_SUBTITLE2);

    // Type of logic
    oneof varid = SETUP_DATA.SkyCam_ControlLogic1_Type,
      prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC1_TYPE),
      help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_ControlLogic1_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_CL1_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic1_CrdVersion == 0x30 0x50;
      // PMIC Flash Panel
      oneof varid   = SETUP_DATA.SkyCam_ControlLogic1_Pld,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL1_PMIC_FLASH_PANEL),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_FLASH_PANEL),
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1_Type == 1;
      // show below options when PMIC is used
      // I2C Channel
      oneof varid = SETUP_DATA.SkyCam_ControlLogic1_I2cChannel,
        prompt   = STRING_TOKEN(STR_SKYCAM_CL1_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_ControlLogic1_I2cAddress,
        prompt   = STRING_TOKEN(STR_SKYCAM_CL1_I2C_ADDRESS_MAIN),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x49,
      endnumeric;

      suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic1_Type == 2 3;
        // WLED1 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic1Wled1Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL1_WLED1_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED1 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic1Wled1FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL1_WLED1_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED1 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic1Wled1TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL1_WLED1_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic1Wled2Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL1_WLED2_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED2 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic1Wled2FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL1_WLED2_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic1Wled2TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL1_WLED2_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;
      endif;
    endif;

    suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic1_Type == 2 3 4;
      // show below options when DISCRETE is used
      // Number of GPIO pins enabled
      numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioPinsEnabled,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_PIN_COUNT),
        help        = STRING_TOKEN(STR_SKYCAM_GPIO_PIN_COUNT),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 4,
        step     = 1,
        default  = 2,
      endnumeric;

      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic1_GpioPinsEnabled == 0;
      // I2C Device 0
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_0);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupPadNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_PAD_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 22,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioFunction[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_FUNCTION0),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioActiveValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_ACTIVE_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioInitialValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_INITIAL_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;

      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic1_GpioPinsEnabled == 0 1;
        // GPIO Pin 1
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_1);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupPadNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_PAD_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioFunction[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_FUNCTION1),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioActiveValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_ACTIVE_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioInitialValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_INITIAL_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic1_GpioPinsEnabled == 0 1 2;
        // GPIO Pin 2
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_2);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupPadNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_PAD_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioFunction[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_FUNCTION2),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioActiveValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_ACTIVE_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioInitialValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_INITIAL_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;


      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic1_GpioPinsEnabled == 0 1 2 3;
        // GPIO Pin 3
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_3);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupPadNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_PAD_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioGroupNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_GROUP_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic1_GpioFunction[3],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_FUNCTION3),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioActiveValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_ACTIVE_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic1_GpioInitialValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL1_GPIO_INITIAL_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;
    endif ;
   endform;

  // *********************************************************
  form formid = AUTO_ID(STR_147_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_TITLE3);
    subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_SUBTITLE3);

    // Type of logic
    oneof varid = SETUP_DATA.SkyCam_ControlLogic2_Type,
      prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC2_TYPE),
      help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_ControlLogic2_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_CL2_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic2_CrdVersion == 0x30 0x50;
      // PMIC Flash Panel
      oneof varid   = SETUP_DATA.SkyCam_ControlLogic2_Pld,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL2_PMIC_FLASH_PANEL),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_FLASH_PANEL),
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2_Type == 1;
      // show below options when PMIC is used
      // I2C Channel
      oneof varid = SETUP_DATA.SkyCam_ControlLogic2_I2cChannel,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL2_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_ControlLogic2_I2cAddress,
        prompt   = STRING_TOKEN(STR_SKYCAM_CL2_I2C_ADDRESS_MAIN),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x49,
      endnumeric;

      suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic2_Type == 2 3;
        // WLED1 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic2Wled1Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL2_WLED1_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED1 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic2Wled1FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL2_WLED1_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED1 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic2Wled1TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL2_WLED1_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic2Wled2Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL2_WLED2_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED2 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic2Wled2FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL2_WLED2_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic2Wled2TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL2_WLED2_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;
      endif;
    endif;

    suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic2_Type == 2 3 4;
      // show below options when DISCRETE is used
      // Number of GPIO pins enabled
      numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioPinsEnabled,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_PIN_COUNT),
        help        = STRING_TOKEN(STR_SKYCAM_GPIO_PIN_COUNT),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 4,
        step     = 1,
        default  = 2,
      endnumeric;

      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic2_GpioPinsEnabled == 0;
      // I2C Device 0
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_0);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupPadNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_PAD_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 22,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioFunction[0],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_FUNCTION0),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioActiveValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_ACTIVE_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioInitialValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_INITIAL_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;

      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic2_GpioPinsEnabled == 0 1;
        // GPIO Pin 1
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_1);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupPadNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_PAD_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioFunction[1],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_FUNCTION1),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioActiveValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_ACTIVE_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioInitialValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_INITIAL_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic2_GpioPinsEnabled == 0 1 2;
        // GPIO Pin 2
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_2);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupPadNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_PAD_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioFunction[2],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_FUNCTION2),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioActiveValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_ACTIVE_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioInitialValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_INITIAL_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;


      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic2_GpioPinsEnabled == 0 1 2 3;
        // GPIO Pin 3
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_3);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupPadNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_PAD_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioGroupNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_GROUP_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic2_GpioFunction[3],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_FUNCTION3),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioActiveValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_ACTIVE_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic2_GpioInitialValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL2_GPIO_INITIAL_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;
    endif ;
   endform;

  // *********************************************************
  form formid = AUTO_ID(STR_148_FORM_ID), // AMI_OVERRIDE
    title    = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_TITLE4);
    subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_OPTIONS_SUBTITLE4);

    // Type of logic
    oneof varid = SETUP_DATA.SkyCam_ControlLogic3_Type,
      prompt   = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC3_TYPE),
      help     = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_TYPE),
      option text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
    endoneof;

    // Version of CRD
    oneof varid = SETUP_DATA.SkyCam_ControlLogic3_CrdVersion,
      prompt   = STRING_TOKEN(STR_SKYCAM_CL3_SDD_CRD),
      help     = STRING_TOKEN(STR_SKYCAM_SDD_CRD),
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SKYCAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
    endoneof;

    suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic3_CrdVersion == 0x30 0x50;
      // PMIC Flash Panel
      oneof varid   = SETUP_DATA.SkyCam_ControlLogic3_Pld,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL3_PMIC_FLASH_PANEL),
        help        = STRING_TOKEN(STR_SKYCAM_PMIC_FLASH_PANEL),
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_SKYCAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3_Type == 1;
      // show below options when PMIC is used
      // I2C Channel
      oneof varid = SETUP_DATA.SkyCam_ControlLogic3_I2cChannel,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL3_I2C_CHANNEL),
        help        = STRING_TOKEN(STR_SKYCAM_I2C_CHANNEL),
        option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // I2C address
      numeric varid = SETUP_DATA.SkyCam_ControlLogic3_I2cAddress,
        prompt   = STRING_TOKEN(STR_SKYCAM_CL3_I2C_ADDRESS_MAIN),
        help     = STRING_TOKEN(STR_SKYCAM_I2C_ADDRESS_MAIN),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 0x7F,
        step     = 1,
        default  = 0x49,
      endnumeric;

      suppressif NOT ideqvallist SETUP_DATA.SkyCam_ControlLogic3_Type == 2 3;
        // WLED1 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic3Wled1Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL3_WLED1_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED1 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic3Wled1FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL3_WLED1_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED1 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic3Wled1TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL3_WLED1_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Type
        oneof varid   = SETUP_DATA.SkyCamControlLogic3Wled2Type,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL3_WLED2_TYPE),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TYPE),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
        endoneof;

        // WLED2 Flash Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic3Wled2FlashMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL3_WLED2_FLASH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_FLASH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x1F,
          step        = 1,
          default     = 0,
        endnumeric;

        // WLED2 Torch Max current
        numeric varid = SETUP_DATA.SkyCamControlLogic3Wled2TorchMaxCurrent,
          prompt      = STRING_TOKEN(STR_SKYCAM_CL3_WLED2_TORCH_MAX_CURRENT),
          help        = STRING_TOKEN(STR_SKYCAM_WLED_TORCH_MAX_CURRENT),
          flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum     = 0,
          maximum     = 0x7,
          step        = 1,
          default     = 0,
        endnumeric;
      endif;
    endif;

    suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic3_Type == 2 3 4;
      // show below options when DISCRETE is used
      // Number of GPIO pins enabled
      numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioPinsEnabled,
        prompt      = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_PIN_COUNT),
        help        = STRING_TOKEN(STR_SKYCAM_GPIO_PIN_COUNT),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 4,
        step     = 1,
        default  = 2,
      endnumeric;

      suppressif ideqval SETUP_DATA.SkyCam_ControlLogic3_GpioPinsEnabled == 0;
      // I2C Device 0
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_0);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupPadNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_PAD_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 22,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupNumber[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_NUMBER0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioFunction[0],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_FUNCTION0),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioActiveValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_ACTIVE_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioInitialValue[0],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_INITIAL_VALUE0),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;

      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic3_GpioPinsEnabled == 0 1;
        // GPIO Pin 1
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_1);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupPadNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_PAD_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupNumber[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_NUMBER1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioFunction[1],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_FUNCTION1),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioActiveValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_ACTIVE_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioInitialValue[1],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_INITIAL_VALUE1),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;

      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic3_GpioPinsEnabled == 0 1 2;
        // GPIO Pin 2
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_2);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupPadNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_PAD_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupNumber[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_NUMBER2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioFunction[2],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_FUNCTION2),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioActiveValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_ACTIVE_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioInitialValue[2],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_INITIAL_VALUE2),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;


      suppressif ideqvallist SETUP_DATA.SkyCam_ControlLogic3_GpioPinsEnabled == 0 1 2 3;
        // GPIO Pin 3
        subtitle text = STRING_TOKEN(STR_SKYCAM_CONTROL_LOGIC_GPIO_3);
        // GPIO Group Pad Number
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupPadNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_PAD_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_PAD_NUMBER),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 23,
          step     = 1,
          default  = 11,
        endnumeric;

        // GPIO Group Number
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioGroupNumber[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_GROUP_NUMBER3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_NUMBER),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Function
        oneof varid = SETUP_DATA.SkyCam_ControlLogic3_GpioFunction[3],
          prompt    = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_FUNCTION3),
          help      = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION),
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SKYCAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
        endoneof;

        // GPIO Active Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioActiveValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_ACTIVE_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_ACTIVE_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 1,
        endnumeric;

        // GPIO Initial Value
        numeric varid = SETUP_DATA.SkyCam_ControlLogic3_GpioInitialValue[3],
          prompt   = STRING_TOKEN(STR_SKYCAM_CL3_GPIO_INITIAL_VALUE3),
          help     = STRING_TOKEN(STR_SKYCAM_GPIO_INITIAL_VALUE),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 1,
          step     = 1,
          default  = 0,
        endnumeric;
      endif;
    endif ;
   endform;

// AMI_OVERRIDE_START   
#endif // End of FORM_SET_FORM
#endif // End of ADVANCED_FORM_SET
// AMI_OVERRIDE_END
